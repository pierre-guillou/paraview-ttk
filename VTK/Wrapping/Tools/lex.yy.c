#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* end standard C headers. */

#ifndef __cplusplus
extern int isatty(int);
#endif /* __cplusplus */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state* YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
 *       access to the local variable yy_act. Since yyless() is a macro, it would break
 *       existing scanners that call yyless() from OUTSIDE yylex.
 *       One obvious solution it to make yy_act a global. I tried that, and saw
 *       a 5% performance hit in a non-yylineno scanner, because yy_act is
 *       normally declared as a register variable-- so it is not worth it.
 */
#define YY_LESS_LINENO(n)                                                                          \
  do                                                                                               \
  {                                                                                                \
    int yyl;                                                                                       \
    for (yyl = n; yyl < yyleng; ++yyl)                                                             \
      if (yytext[yyl] == '\n')                                                                     \
        --yylineno;                                                                                \
  } while (0)
#define YY_LINENO_REWIND_TO(dst)                                                                   \
  do                                                                                               \
  {                                                                                                \
    const char* p;                                                                                 \
    for (p = yy_cp - 1; p >= (dst); --p)                                                           \
      if (*p == '\n')                                                                              \
        --yylineno;                                                                                \
  } while (0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    *yy_cp = (yy_hold_char);                                                                       \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;        \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                                                 \
  } while (0)
#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
  FILE* yy_input_file;

  char* yy_ch_buf;  /* input buffer */
  char* yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  int yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  int yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE* yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char* yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart(FILE* input_file);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_flush_buffer(YY_BUFFER_STATE b);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void yypop_buffer_state(void);

static void yyensure_buffer_stack(void);
static void yy_load_buffer_state(void);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)

YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string(const char* yy_str);
YY_BUFFER_STATE yy_scan_bytes(const char* bytes, int len);

void* yyalloc(yy_size_t);
void* yyrealloc(void*, yy_size_t);
void yyfree(void*);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                                  \
  }
#define yy_set_bol(at_bol)                                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                                  \
  }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char* yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state(void);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer(void);
static void yynoreturn yy_fatal_error(const char* msg);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                                        \
  (yytext_ptr) = yy_bp;                                                                            \
  yyleng = (int)(yy_cp - yy_bp);                                                                   \
  (yy_hold_char) = *yy_cp;                                                                         \
  *yy_cp = '\0';                                                                                   \
  (yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 165
#define YY_END_OF_BUFFER 166
static const flex_int16_t yy_accept[968] = { 0, 0, 0, 166, 164, 128, 129, 129, 163, 164, 163, 163,
  164, 163, 163, 163, 163, 163, 163, 163, 126, 125, 163, 163, 163, 163, 117, 117, 117, 117, 117,
  117, 117, 117, 161, 164, 162, 163, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 163, 128, 13, 13, 15, 163, 164, 128, 156, 0, 16, 0, 135,
  149, 132, 153, 150, 0, 0, 0, 90, 91, 0, 0, 0, 0, 0, 147, 143, 145, 144, 146, 142, 140, 0, 118, 3,
  14, 148, 0, 119, 124, 0,

  0, 0, 0, 0, 125, 125, 125, 160, 134, 131, 133, 139, 157, 155, 158, 136, 117, 117, 117, 0, 0, 117,
  117, 117, 0, 117, 0, 130, 127, 0, 152, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 81,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 151, 154, 128, 13, 15, 0, 0, 15, 15, 3, 12, 0, 0, 0, 17, 0, 0,

  0, 0, 0, 0, 141, 159, 0, 118, 118, 118, 0, 14, 14, 120, 119, 119, 124, 124, 0, 123, 0, 121, 122,
  125, 121, 137, 138, 117, 117, 117, 0, 0, 18, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 79, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 26, 117, 117, 117, 117, 65, 117, 83, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 69, 117, 117, 117,

  117, 117, 117, 117, 117, 117, 85, 0, 12, 15, 2, 12, 12, 6, 12, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 118, 0, 118, 1, 5, 0, 120, 120, 120, 119, 0, 119, 124, 121, 0, 123, 123, 0, 121, 121, 0,
  122, 122, 122, 121, 121, 117, 117, 117, 0, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 19, 117, 117, 30, 117, 25, 117, 117, 117, 117, 117, 117,
  117, 117, 47, 117, 117, 117, 117, 117, 117, 24, 117,

  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 0, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 29, 117, 117, 117, 117, 2, 12, 12, 6, 12, 12, 12, 6, 5, 7,
  8, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 118, 118, 5, 120, 0, 120, 119, 0, 119, 119, 121,
  121, 123, 121, 122, 122, 122, 122, 121, 117, 117, 117, 101, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,

  117, 88, 70, 117, 117, 42, 89, 50, 117, 117, 117, 117, 117, 117, 117, 21, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 82, 117, 117, 117, 117, 117, 117, 23, 117, 117, 117, 117, 117, 0, 117, 117,
  117, 117, 68, 117, 117, 48, 117, 64, 117, 117, 117, 117, 117, 12, 12, 6, 7, 8, 12, 12, 12, 5, 7,
  8, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 118, 120, 0, 120, 120, 119, 121, 117, 117, 117, 101, 96, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,

  117, 117, 117, 117, 117, 80, 87, 117, 117, 117, 117, 117, 117, 66, 20, 117, 117, 59, 54, 55, 117,
  117, 117, 117, 84, 117, 117, 117, 117, 117, 44, 117, 117, 117, 28, 117, 117, 57, 0, 0, 0, 0, 117,
  43, 117, 117, 117, 117, 117, 117, 117, 117, 117, 86, 12, 12, 12, 7, 8, 12, 12, 12, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 120, 117, 117, 117, 95, 117, 107, 117, 117, 109, 117, 117, 113, 117, 117, 117, 22,
  117, 117, 117, 117, 103, 117, 117, 117, 117, 117, 73,

  117, 117, 117, 52, 117, 117, 116, 117, 117, 45, 117, 0, 117, 117, 117, 34, 34, 117, 117, 0, 0, 0,
  0, 0, 0, 99, 99, 117, 117, 62, 117, 117, 49, 117, 117, 33, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0,
  93, 94, 0, 0, 0, 0, 0, 96, 96, 37, 104, 105, 117, 117, 117, 117, 117, 117, 110, 117, 117, 117, 31,
  32, 117, 117, 72, 117, 67, 98, 98, 117, 71, 117, 53, 97, 97, 0, 117, 0, 78, 117, 0, 41, 35, 35,
  117, 117, 0, 0, 0, 0, 0,

  0, 60, 117, 61, 27, 51, 117, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 108, 117, 117,
  117, 117, 117, 117, 117, 56, 117, 63, 117, 0, 46, 0, 117, 117, 117, 0, 0, 0, 0, 0, 0, 117, 117,
  12, 12, 12, 10, 12, 12, 0, 0, 0, 0, 117, 117, 112, 115, 76, 117, 36, 36, 0, 0, 0, 117, 117, 117,
  0, 0, 0, 0, 0, 0, 117, 117, 10, 12, 12, 10, 12, 12, 0, 4, 117, 117, 117, 117, 0, 0, 0, 117, 117,
  74, 0,

  0, 0, 0, 0, 0, 117, 117, 10, 12, 12, 12, 12, 0, 117, 117, 114, 75, 0, 0, 0, 117, 117, 0, 0, 0, 0,
  58, 100, 12, 12, 11, 12, 0, 106, 111, 0, 0, 0, 38, 117, 102, 0, 11, 12, 11, 12, 0, 0, 39, 0, 117,
  0, 11, 12, 12, 0, 0, 117, 12, 9, 0, 40, 77, 9, 9, 9, 0 };

static const YY_CHAR yy_ec[256] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 4, 5, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 7, 8, 9, 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
  22, 23, 24, 25, 26, 27, 26, 28, 29, 30, 17, 31, 32, 33, 1, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
  44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 42, 56, 57, 58, 42, 59, 60, 61, 62, 63, 1, 64, 65,
  66, 67,

  68, 69, 70, 71, 72, 42, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
  91, 17, 1, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92,

  92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92, 92, 92, 92, 92 };

static const YY_CHAR yy_meta[93] = { 0, 1, 2, 3, 4, 5, 2, 1, 1, 1, 1, 6, 7, 1, 4, 6, 1, 1, 1, 8, 1,
  9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 1, 1, 1, 1, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 13, 12, 12, 12, 12, 12, 12, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 14

};

static const flex_int16_t yy_base[1074] = { 0, 0, 91, 2816, 2817, 93, 2817, 2817, 2783, 90, 71, 91,
  2754, 103, 2817, 2781, 94, 89, 120, 97, 155, 174, 83, 121, 2780, 87, 2761, 0, 2775, 116, 52, 2801,
  152, 2765, 152, 127, 2817, 2775, 174, 87, 113, 98, 139, 51, 91, 111, 2729, 2722, 142, 149, 53,
  2736, 162, 167, 224, 168, 2737, 2725, 124, 253, 2817, 2817, 2741, 231, 2728, 215, 2817, 197, 2736,
  2793, 2817, 2817, 2817, 2817, 2817, 206, 236, 266, 2817, 2817, 158, 2767, 230, 231, 201, 2817,
  2817, 2817, 2817, 2817, 2781, 2817, 2776, 267, 260, 263, 2817, 286, 315, 334, 353,

  263, 372, 0, 382, 401, 0, 420, 2817, 2817, 2817, 2817, 2762, 2817, 2817, 2817, 2761, 0, 2749,
  2745, 270, 2730, 2781, 2739, 2757, 2773, 2737, 412, 2817, 2817, 2781, 2817, 242, 2715, 2705, 2701,
  2709, 386, 2707, 2711, 2695, 2694, 2698, 2692, 2709, 2708, 222, 251, 2688, 2694, 2686, 171, 2691,
  2695, 244, 2684, 2689, 2682, 2688, 2677, 251, 2687, 2692, 2696, 2676, 227, 2692, 210, 2679, 257,
  2683, 267, 2679, 2673, 2665, 2673, 379, 251, 2678, 2669, 276, 2675, 2676, 2666, 2817, 2817, 454,
  2817, 2685, 349, 2672, 2683, 429, 447, 466, 276, 0, 462, 2679, 2711, 2710,

  341, 143, 319, 409, 2817, 2817, 480, 502, 0, 521, 2708, 0, 2707, 539, 0, 558, 0, 572, 587, 471,
  596, 614, 632, 0, 652, 2817, 2817, 2698, 2690, 2688, 2680, 2693, 2817, 2670, 2610, 2591, 2588,
  2583, 2586, 2569, 2554, 254, 2567, 2558, 2545, 2528, 2539, 2502, 2499, 2494, 2495, 2478, 417,
  2476, 2478, 2461, 2455, 2455, 2447, 2451, 2450, 2432, 2421, 2408, 2383, 2370, 2362, 2352, 2334,
  2324, 0, 2310, 2314, 2314, 2304, 0, 2283, 2301, 2284, 2272, 2278, 2263, 2254, 2250, 2255, 2252,
  2245, 2236, 2237, 2240, 2206, 2206, 2252, 404, 2201, 442, 0, 2206, 2194, 2188,

  2178, 2158, 2159, 2148, 2145, 2120, 2107, 470, 682, 458, 2125, 0, 347, 2116, 279, 2063, 2053, 0,
  472, 0, 401, 481, 256, 449, 466, 452, 487, 465, 0, 682, 700, 2817, 0, 709, 727, 0, 746, 0, 755,
  775, 0, 793, 476, 670, 0, 802, 820, 0, 0, 838, 896, 0, 858, 0, 2084, 2091, 2077, 0, 2068, 2043,
  2035, 2039, 2033, 2025, 2024, 2005, 2013, 2000, 2012, 1992, 1988, 2001, 1978, 1989, 1979, 1969,
  1971, 0, 1960, 1943, 0, 1946, 411, 1933, 1929, 1920, 1919, 1917, 1917, 1917, 1902, 0, 1891, 1877,
  1872, 1873, 1870, 1873, 0, 1873,

  1852, 1866, 1862, 1847, 1855, 1834, 1842, 1841, 1820, 1803, 1793, 1791, 1786, 470, 1801, 1790,
  1778, 1806, 1754, 1761, 1734, 1738, 1711, 445, 1712, 1717, 1716, 1702, 0, 1702, 1699, 1691, 1678,
  2817, 0, 516, 0, 424, 504, 1677, 0, 0, 0, 0, 1670, 1675, 0, 0, 389, 523, 525, 559, 526, 547, 562,
  561, 916, 867, 945, 0, 0, 0, 925, 963, 981, 990, 1008, 0, 1026, 0, 0, 0, 1044, 1102, 0, 0, 0,
  1688, 1706, 1701, 0, 1696, 1662, 1665, 1656, 1653, 1659, 1669, 1652, 1665, 1664, 1655, 1646, 1700,
  1656, 1643, 1658, 1642, 1658, 1642,

  1649, 0, 0, 1688, 1691, 0, 0, 582, 1626, 1638, 1643, 1642, 1637, 1642, 1631, 0, 1639, 1637, 1640,
  1629, 1624, 1633, 1621, 1617, 1616, 0, 1633, 1614, 1629, 1628, 1611, 1586, 0, 1579, 1585, 1569,
  1587, 1583, 713, 1578, 1565, 1582, 1578, 0, 1576, 1579, 0, 1566, 0, 1577, 1568, 1572, 1575, 1558,
  598, 1568, 0, 0, 0, 1600, 1595, 1552, 0, 0, 0, 1564, 1551, 0, 632, 617, 528, 600, 618, 601, 619,
  633, 1064, 1122, 1073, 1151, 0, 1169, 0, 1578, 1592, 1587, 0, 1573, 1558, 1555, 1548, 1536, 1554,
  1550, 1544, 1541, 1550, 1532, 1546, 1586,

  1535, 1529, 1544, 1541, 1525, 0, 0, 1542, 1541, 1537, 1516, 1523, 1480, 0, 0, 1495, 1488, 0, 0, 0,
  1484, 1490, 1493, 1478, 0, 1475, 1477, 1478, 1484, 1469, 738, 1482, 1469, 1467, 0, 1198, 1465,
  1483, 1464, 1461, 1462, 828, 1290, 0, 1460, 1478, 1471, 1464, 1470, 1463, 1458, 1478, 1448, 0,
  1494, 1489, 1446, 0, 0, 1479, 1488, 1458, 1448, 1453, 635, 683, 1231, 685, 727, 803, 728, 805,
  1226, 1463, 1475, 1465, 0, 1437, 0, 1451, 1436, 0, 1452, 1449, 0, 1439, 1434, 1447, 0, 1446, 1437,
  1396, 1405, 0, 1386, 1385, 1402, 1386, 1395, 0,

  1399, 1379, 1382, 0, 1394, 1377, 1395, 1377, 1474, 804, 1388, 834, 1375, 1376, 953, 2817, 0, 1566,
  538, 1371, 1378, 1369, 1361, 1376, 1367, 2817, 0, 1378, 1366, 0, 1371, 1371, 0, 1369, 1354, 0,
  1388, 1397, 1367, 1393, 1377, 1349, 1360, 1363, 660, 715, 1101, 2817, 1394, 1323, 687, 804, 689,
  808, 1369, 1327, 0, 0, 0, 1300, 1301, 1291, 1299, 1304, 1297, 0, 1304, 1294, 1293, 0, 0, 1285,
  1285, 0, 1297, 0, 2817, 0, 1294, 0, 1279, 0, 2817, 0, 849, 1293, 1285, 0, 1277, 992, 2817, 2817,
  0, 1275, 1291, 1274, 1274, 1267, 1278, 1247,

  1260, 0, 1250, 0, 0, 0, 1206, 1246, 1230, 1203, 1276, 1237, 1207, 1202, 1211, 1328, 1415, 1150,
  2817, 712, 782, 783, 823, 0, 1199, 1193, 1208, 1199, 1190, 1197, 1188, 0, 1205, 0, 1658, 1194,
  974, 1189, 1197, 1183, 1182, 1194, 1178, 1177, 1181, 1173, 1159, 1123, 1116, 1181, 1142, 1112, 0,
  1134, 1104, 1082, 1089, 951, 952, 1088, 1054, 0, 1058, 0, 1039, 2817, 0, 1042, 1037, 1035, 1033,
  1037, 996, 1013, 993, 1010, 982, 1000, 992, 997, 984, 0, 1010, 980, 0, 1009, 964, 981, 2817, 980,
  323, 326, 369, 417, 498, 492, 540, 525, 0, 557,

  554, 618, 0, 612, 0, 621, 676, 0, 699, 683, 782, 721, 726, 737, 795, 0, 0, 817, 822, 1130, 835,
  829, 0, 849, 0, 0, 0, 0, 907, 842, 0, 839, 854, 0, 0, 1156, 845, 1237, 2817, 865, 0, 896, 0, 919,
  0, 923, 923, 1334, 2817, 920, 940, 0, 0, 947, 994, 951, 1339, 946, 1011, 0, 1420, 2817, 0, 0, 0,
  0, 2817, 1750, 1764, 1777, 1785, 1791, 1805, 1811, 1819, 1833, 1839, 1847, 1853, 1857, 1871, 1885,
  1888, 1894, 1902, 1908, 1914, 1922, 1930, 1938, 1946, 1960, 1974, 1980, 1983, 1992, 1998, 2006,
  2020, 2028,

  2034, 2040, 2048, 2054, 2062, 2070, 2076, 2084, 2090, 2096, 2102, 2110, 2116, 2124, 2130, 2136,
  2139, 2153, 2167, 2181, 2195, 2209, 2223, 2237, 2243, 2249, 2255, 2263, 2271, 2277, 2291, 2297,
  2305, 2313, 2321, 2327, 2335, 2341, 2347, 2353, 2361, 2367, 2373, 2379, 2385, 2399, 2413, 2427,
  2441, 2455, 2469, 2483, 2497, 2503, 2509, 2517, 2525, 2533, 2539, 2547, 2553, 2567, 2581, 2595,
  2609, 2623, 2637, 2651, 2665, 2679, 2693, 2707, 2721 };

static const flex_int16_t yy_def[1074] = { 0, 967, 1, 967, 967, 967, 967, 967, 967, 968, 967, 967,
  969, 970, 967, 967, 967, 967, 967, 967, 967, 971, 967, 967, 967, 967, 972, 972, 972, 972, 972,
  972, 972, 972, 967, 967, 967, 967, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972,
  972, 972, 972, 972, 972, 972, 972, 972, 967, 967, 967, 967, 973, 967, 967, 967, 967, 968, 967,
  968, 967, 967, 967, 967, 967, 969, 969, 970, 967, 967, 974, 974, 974, 974, 974, 967, 967, 967,
  967, 967, 967, 967, 967, 975, 967, 976, 967, 967, 977, 978, 967,

  967, 967, 979, 967, 971, 980, 980, 967, 967, 967, 967, 967, 967, 967, 967, 967, 972, 972, 972,
  968, 969, 972, 972, 972, 981, 972, 967, 967, 967, 967, 967, 972, 972, 972, 972, 972, 972, 972,
  972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972,
  972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972,
  972, 972, 972, 972, 972, 972, 972, 967, 967, 967, 967, 973, 967, 967, 973, 973, 967, 982, 967,
  983, 968, 967, 974, 967,

  974, 974, 974, 974, 967, 967, 967, 975, 984, 984, 967, 976, 976, 985, 986, 986, 987, 987, 967,
  988, 967, 989, 990, 980, 991, 967, 967, 972, 972, 972, 967, 981, 967, 972, 972, 972, 972, 972,
  972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972,
  972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972,
  972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972, 972,
  972, 972, 972, 972, 972,

  972, 972, 972, 972, 972, 972, 972, 967, 992, 973, 967, 982, 982, 993, 982, 967, 967, 994, 968,
  995, 996, 997, 997, 997, 997, 997, 997, 997, 984, 967, 998, 967, 999, 967, 1000, 1001, 1001, 1002,
  967, 1003, 1004, 1005, 967, 1006, 1007, 967, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016,
  1016, 1016, 1017, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016,
  1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016,
  1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016,

  1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016,
  1016, 967, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016,
  1016, 967, 1018, 1018, 1019, 1018, 1020, 1020, 1021, 1022, 1023, 1024, 967, 967, 1025, 1026, 1027,
  1027, 1027, 1027, 1027, 1027, 1027, 1027, 1028, 967, 1029, 1030, 1031, 1032, 967, 1033, 1034, 967,
  1035, 1036, 1037, 1038, 1039, 1040, 1041, 1041, 1042, 1042, 1043, 1044, 1044, 1044, 1045, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044,

  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 967, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 1046, 1046, 1047, 1048, 1049, 1050, 1050, 1050, 1051, 1052,
  1053, 967, 967, 1054, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1056, 1057, 967, 1058, 1059,
  1060, 1061, 1044, 1044, 1044, 1045, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044,

  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 967, 967, 967, 967, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1046, 1046, 1046, 1048, 1049, 1050, 1050, 1050, 967, 967, 1055,
  1055, 1055, 1055, 1055, 1055, 1055, 1055, 1057, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044,

  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 967, 1044, 1044, 1044, 967,
  1044, 1044, 1044, 967, 967, 967, 967, 967, 967, 967, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1046, 1046, 1046, 1050, 1050, 1050, 967, 967, 1055, 1055, 967, 967, 1055, 1055,
  1055, 1055, 1055, 1055, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 967, 1044, 1044, 1044, 1044, 1044,
  967, 1044, 967, 1044, 967, 1044, 1044, 967, 967, 967, 1044, 1044, 1044, 967, 967, 967, 967, 967,

  967, 1044, 1044, 1044, 1044, 1044, 1044, 1046, 1046, 1046, 1050, 1050, 1050, 967, 967, 1055, 1055,
  967, 967, 1055, 1055, 1055, 1055, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 967, 1044, 967, 1044, 1044, 1044, 967, 967, 967, 967, 967, 967, 1044, 1044, 1046,
  1046, 1046, 1062, 1050, 1050, 967, 967, 1055, 1055, 1044, 1044, 1044, 1044, 1044, 1044, 967, 1044,
  967, 967, 967, 1044, 1044, 1044, 967, 967, 967, 967, 967, 967, 1044, 1044, 1063, 1046, 1046, 1062,
  1050, 1050, 967, 967, 1044, 1044, 1044, 1044, 967, 967, 967, 1044, 1044, 1044, 967,

  967, 967, 1064, 967, 1065, 1044, 1044, 1063, 1046, 1046, 1050, 1050, 967, 1044, 1044, 1044, 1044,
  967, 967, 967, 1044, 1044, 1066, 967, 1067, 1068, 1044, 1044, 1046, 1046, 1069, 1050, 967, 1044,
  1044, 967, 967, 967, 967, 1044, 1044, 967, 1070, 1046, 1069, 1050, 967, 967, 967, 967, 1044, 1071,
  1070, 1046, 1050, 967, 967, 1044, 1046, 1072, 967, 967, 1044, 1073, 1072, 1073, 0, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,

  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967 };

static const flex_int16_t yy_nxt[2910] = { 0, 4, 5, 6, 7, 7, 5, 8, 9, 4, 10, 11, 12, 13, 14, 15, 16,
  14, 17, 18, 19, 20, 21, 21, 21, 21, 21, 21, 21, 21, 22, 23, 24, 25, 4, 26, 27, 28, 27, 27, 27, 27,
  27, 27, 27, 27, 29, 27, 27, 27, 27, 30, 31, 27, 27, 32, 33, 27, 27, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 27, 27, 45, 27, 46, 47, 48, 49, 50, 27, 51, 52, 53, 54, 55, 56, 57, 27, 27, 14,
  58, 14, 27, 59, 60, 65, 61, 59, 68, 65, 62,

  70, 73, 71, 72, 77, 77, 88, 77, 77, 86, 63, 94, 108, 78, 123, 109, 95, 79, 115, 116, 89, 90, 74,
  120, 64, 87, 150, 121, 96, 129, 110, 130, 165, 124, 91, 166, 151, 80, 92, 82, 93, 93, 93, 93, 93,
  93, 93, 93, 93, 69, 111, 112, 113, 127, 127, 184, 127, 127, 83, 120, 138, 143, 139, 121, 152, 84,
  97, 122, 144, 140, 153, 145, 200, 98, 146, 99, 99, 99, 99, 99, 99, 99, 99, 100, 141, 104, 154,
  200, 323, 142, 101, 155, 98, 102, 105, 105, 105, 105, 105, 105,

  105, 105, 105, 122, 68, 158, 147, 201, 132, 159, 128, 103, 107, 185, 133, 148, 65, 198, 160, 101,
  65, 134, 102, 135, 161, 149, 162, 136, 163, 164, 200, 120, 168, 169, 172, 121, 137, 173, 967, 179,
  103, 107, 170, 171, 180, 193, 174, 75, 266, 181, 194, 176, 267, 175, 186, 187, 69, 187, 186, 200,
  200, 188, 96, 204, 202, 76, 211, 77, 77, 213, 77, 77, 189, 203, 211, 122, 78, 68, 207, 286, 79,
  287, 213, 220, 220, 200, 190, 208, 208, 208, 208, 208, 208, 208, 208, 208, 258, 259, 283, 177,

  80, 450, 82, 284, 178, 210, 99, 99, 99, 99, 99, 99, 99, 99, 100, 235, 260, 270, 277, 261, 367, 83,
  299, 236, 262, 271, 289, 368, 84, 69, 292, 300, 278, 293, 210, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 290, 97, 294, 303, 200, 304, 316, 317, 98, 216, 99, 99, 99, 99, 99, 99, 99, 99, 100,
  308, 219, 439, 324, 443, 309, 444, 200, 98, 218, 100, 100, 100, 100, 100, 100, 100, 100, 100, 216,
  322, 440, 915, 120, 221, 916, 221, 121, 102, 222, 222, 222, 222, 222, 222, 222, 222,

  222, 218, 105, 105, 105, 105, 105, 105, 105, 105, 105, 78, 104, 127, 127, 79, 127, 127, 200, 98,
  102, 105, 105, 105, 105, 105, 105, 105, 105, 105, 122, 191, 504, 310, 505, 221, 569, 221, 200,
  107, 225, 225, 225, 225, 225, 225, 225, 225, 225, 241, 917, 242, 243, 311, 244, 186, 187, 245,
  187, 186, 191, 311, 188, 246, 319, 247, 248, 249, 107, 68, 128, 313, 314, 189, 325, 419, 434, 326,
  200, 68, 379, 200, 343, 451, 434, 314, 420, 190, 192, 327, 328, 344, 344, 380, 200, 200, 344, 344,
  918, 315,

  208, 208, 208, 208, 208, 208, 208, 208, 208, 422, 200, 545, 558, 207, 559, 454, 200, 192, 423,
  449, 546, 69, 208, 208, 208, 208, 208, 208, 208, 208, 208, 69, 452, 534, 555, 456, 330, 535, 330,
  453, 210, 331, 331, 331, 331, 331, 331, 331, 331, 331, 334, 560, 200, 556, 200, 200, 561, 200,
  570, 335, 335, 335, 335, 335, 335, 335, 335, 335, 455, 210, 667, 919, 920, 339, 571, 339, 200,
  337, 340, 340, 340, 340, 340, 340, 340, 340, 340, 221, 200, 221, 200, 200, 342, 342, 342, 342,
  342, 342, 342, 342,

  342, 794, 921, 795, 922, 573, 337, 100, 100, 100, 100, 100, 100, 100, 100, 100, 222, 222, 222,
  222, 222, 222, 222, 222, 222, 346, 572, 574, 575, 200, 200, 923, 576, 924, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 349, 610, 655, 200, 200, 200, 611, 656, 666, 350, 350, 350, 350, 350,
  350, 350, 350, 350, 200, 200, 346, 200, 668, 351, 351, 351, 351, 351, 351, 353, 353, 353, 353,
  353, 353, 353, 353, 353, 343, 670, 669, 671, 665, 745, 436, 437, 200, 344, 344, 925, 926, 927,
  351, 351, 351, 351, 351,

  351, 437, 457, 457, 457, 457, 457, 457, 457, 457, 457, 458, 200, 672, 200, 438, 200, 816, 200,
  746, 459, 459, 459, 459, 459, 459, 459, 459, 459, 335, 335, 335, 335, 335, 335, 335, 335, 335,
  334, 712, 712, 200, 712, 712, 200, 928, 929, 335, 335, 335, 335, 335, 335, 335, 335, 335, 200,
  200, 750, 817, 820, 463, 822, 463, 930, 337, 464, 464, 464, 464, 464, 464, 464, 464, 464, 465,
  465, 465, 465, 465, 465, 465, 465, 465, 639, 750, 466, 931, 640, 641, 751, 753, 932, 642, 337,
  467, 467, 467, 467, 467,

  467, 467, 467, 467, 346, 785, 785, 933, 785, 785, 934, 200, 200, 469, 469, 469, 469, 469, 469,
  469, 469, 469, 347, 347, 347, 347, 347, 347, 347, 347, 347, 346, 200, 200, 200, 712, 712, 200,
  712, 712, 347, 347, 347, 347, 347, 347, 347, 347, 347, 349, 785, 785, 200, 785, 785, 858, 750,
  935, 350, 350, 350, 350, 350, 350, 350, 350, 350, 821, 752, 346, 754, 823, 351, 351, 351, 351,
  351, 351, 353, 353, 353, 353, 353, 353, 353, 353, 353, 577, 577, 577, 577, 577, 577, 577, 577,
  577, 859, 936, 937, 723,

  940, 351, 351, 351, 351, 351, 351, 349, 724, 725, 941, 942, 943, 944, 787, 946, 473, 473, 473,
  473, 473, 473, 473, 473, 473, 947, 950, 458, 951, 836, 474, 474, 474, 474, 474, 474, 577, 577,
  577, 577, 577, 577, 577, 577, 577, 578, 578, 578, 578, 578, 578, 578, 578, 578, 790, 790, 458,
  790, 790, 474, 474, 474, 474, 474, 474, 459, 459, 459, 459, 459, 459, 459, 459, 459, 579, 869,
  869, 952, 869, 869, 200, 200, 791, 580, 580, 580, 580, 580, 580, 580, 580, 580, 466, 790, 790,
  954, 790, 790, 955, 956,

  957, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582,
  466, 958, 791, 959, 960, 750, 750, 889, 963, 467, 467, 467, 467, 467, 467, 467, 467, 467, 346,
  869, 869, 964, 869, 869, 914, 913, 912, 469, 469, 469, 469, 469, 469, 469, 469, 469, 349, 911,
  910, 909, 907, 906, 905, 904, 903, 473, 473, 473, 473, 473, 473, 473, 473, 473, 902, 901, 458,
  900, 899, 474, 474, 474, 474, 474, 474, 577, 577, 577, 577, 577, 577, 577, 577, 577, 673, 673,
  673, 673, 673, 673, 673,

  673, 673, 747, 747, 898, 747, 747, 474, 474, 474, 474, 474, 474, 349, 897, 748, 896, 895, 894,
  893, 892, 891, 473, 473, 473, 473, 473, 473, 473, 473, 473, 938, 938, 579, 938, 938, 474, 474,
  474, 474, 474, 474, 673, 673, 673, 673, 673, 673, 673, 673, 673, 818, 818, 890, 818, 818, 889,
  948, 948, 939, 948, 948, 579, 888, 819, 474, 474, 474, 474, 474, 474, 580, 580, 580, 580, 580,
  580, 580, 580, 580, 466, 887, 886, 884, 883, 949, 882, 881, 880, 582, 582, 582, 582, 582, 582,
  582, 582, 582, 716, 716,

  716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 716, 717,
  717, 717, 717, 717, 717, 717, 717, 717, 716, 716, 716, 716, 716, 747, 747, 879, 747, 747, 579,
  938, 938, 878, 938, 938, 877, 876, 748, 673, 673, 673, 673, 673, 673, 673, 673, 673, 875, 716,
  716, 716, 716, 200, 874, 873, 872, 871, 870, 939, 868, 865, 864, 685, 863, 685, 862, 861, 860,
  857, 856, 855, 854, 749, 853, 852, 851, 850, 849, 716, 716, 716, 717, 726, 726, 726, 726, 726,
  726, 726, 726, 726, 726,

  726, 726, 726, 726, 726, 726, 726, 726, 726, 726, 727, 727, 727, 727, 727, 727, 727, 727, 727,
  726, 726, 726, 726, 726, 818, 818, 848, 818, 818, 747, 747, 847, 747, 747, 846, 948, 948, 819,
  948, 948, 961, 961, 748, 961, 961, 845, 844, 843, 726, 726, 726, 726, 200, 842, 841, 840, 839,
  200, 838, 837, 835, 834, 833, 949, 832, 831, 830, 685, 962, 829, 828, 827, 685, 826, 825, 824,
  677, 749, 726, 726, 726, 727, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777,
  777, 777, 777, 777, 777,

  777, 777, 778, 778, 778, 778, 778, 778, 778, 778, 778, 777, 777, 777, 777, 777, 747, 747, 677,
  747, 747, 961, 961, 200, 961, 961, 815, 814, 813, 748, 812, 811, 810, 809, 808, 807, 806, 805,
  804, 803, 777, 777, 777, 777, 200, 802, 801, 800, 799, 962, 798, 797, 796, 789, 788, 786, 782,
  781, 780, 779, 776, 775, 774, 773, 749, 772, 771, 770, 769, 768, 777, 777, 777, 778, 783, 783,
  783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 784,
  784, 784, 784, 784, 784,

  784, 784, 784, 783, 783, 783, 783, 783, 767, 766, 765, 764, 763, 762, 761, 760, 759, 758, 757,
  756, 755, 744, 743, 742, 741, 740, 739, 738, 737, 736, 735, 734, 783, 783, 783, 783, 733, 732,
  731, 730, 729, 728, 722, 721, 720, 719, 718, 715, 714, 713, 711, 710, 709, 708, 707, 706, 705,
  704, 703, 702, 701, 700, 783, 783, 783, 784, 792, 792, 792, 792, 792, 792, 792, 792, 792, 792,
  792, 792, 792, 792, 792, 792, 792, 792, 792, 792, 793, 793, 793, 793, 793, 793, 793, 793, 793,
  792, 792, 792, 792, 792,

  699, 698, 697, 696, 695, 694, 693, 692, 691, 690, 689, 688, 687, 686, 685, 684, 683, 682, 681,
  680, 679, 678, 677, 676, 792, 792, 792, 792, 675, 674, 664, 663, 662, 661, 660, 657, 654, 653,
  652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 638, 637, 636, 635, 634, 633, 792, 792, 792,
  793, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866, 866,
  866, 866, 867, 867, 867, 867, 867, 867, 867, 867, 867, 866, 866, 866, 866, 866, 632, 631, 630,
  629, 628, 627, 626, 625,

  624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 609, 608, 607, 866, 866, 866,
  866, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 590, 589,
  588, 586, 585, 584, 567, 566, 562, 554, 866, 866, 866, 867, 67, 67, 67, 67, 67, 67, 67, 67, 67,
  67, 67, 67, 67, 67, 75, 75, 75, 75, 75, 75, 553, 75, 75, 75, 75, 75, 75, 75, 81, 81, 552, 81, 81,
  551, 550, 549, 548, 547, 81, 81, 81, 106, 106, 106, 106, 544, 106, 106, 106, 117,

  117, 543, 117, 117, 117, 191, 191, 542, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191,
  199, 199, 199, 199, 199, 199, 209, 541, 209, 209, 540, 209, 209, 209, 212, 212, 539, 212, 212,
  212, 212, 212, 212, 212, 212, 212, 212, 212, 215, 215, 538, 215, 215, 215, 217, 217, 217, 217,
  537, 217, 217, 217, 223, 223, 536, 223, 224, 224, 533, 224, 224, 224, 232, 532, 531, 530, 232,
  232, 232, 232, 232, 232, 232, 232, 232, 232, 312, 312, 529, 312, 312, 312, 312, 312, 312, 312,
  312, 312, 312, 312, 318,

  318, 318, 329, 329, 528, 329, 329, 329, 336, 527, 336, 336, 526, 336, 336, 336, 338, 338, 525,
  338, 338, 338, 341, 341, 524, 341, 341, 341, 345, 523, 345, 522, 521, 345, 345, 345, 348, 520,
  348, 348, 519, 348, 348, 348, 352, 518, 352, 352, 517, 352, 352, 352, 354, 516, 354, 354, 515,
  354, 354, 354, 435, 435, 514, 435, 435, 435, 435, 435, 435, 435, 435, 435, 435, 435, 441, 441,
  513, 441, 441, 441, 441, 441, 441, 441, 441, 441, 441, 441, 447, 447, 512, 447, 447, 447, 448,
  448, 448, 81, 511, 510,

  509, 508, 507, 81, 81, 81, 199, 199, 199, 199, 199, 199, 460, 506, 460, 460, 503, 460, 460, 460,
  461, 461, 502, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 461, 336, 501, 336, 336, 500,
  336, 336, 336, 462, 462, 499, 462, 462, 462, 338, 338, 498, 338, 338, 338, 468, 497, 468, 468,
  496, 468, 468, 468, 341, 341, 495, 341, 341, 341, 470, 494, 470, 470, 493, 470, 470, 470, 345,
  492, 345, 491, 490, 345, 345, 345, 471, 471, 489, 471, 471, 471, 348, 488, 348, 348, 487, 348,
  348, 348, 472, 472,

  486, 472, 472, 472, 350, 350, 485, 350, 352, 484, 352, 352, 483, 352, 352, 352, 475, 482, 475,
  475, 480, 475, 475, 475, 476, 476, 479, 476, 476, 476, 354, 478, 354, 354, 446, 354, 354, 354,
  477, 477, 445, 477, 477, 477, 117, 117, 442, 117, 117, 117, 481, 481, 481, 435, 435, 332, 435,
  435, 435, 435, 435, 435, 435, 435, 435, 435, 435, 557, 557, 433, 557, 557, 557, 557, 557, 557,
  557, 557, 557, 557, 557, 312, 312, 432, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
  441, 441, 431, 441, 441,

  441, 441, 441, 441, 441, 441, 441, 441, 441, 563, 563, 430, 563, 563, 563, 563, 563, 563, 563,
  563, 563, 563, 563, 564, 564, 429, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 564, 565,
  565, 428, 565, 565, 565, 565, 565, 565, 565, 565, 565, 565, 565, 447, 447, 427, 447, 447, 447,
  568, 568, 426, 568, 568, 568, 199, 199, 199, 199, 199, 199, 209, 425, 209, 209, 424, 209, 209,
  209, 460, 421, 460, 460, 418, 460, 460, 460, 329, 329, 417, 329, 329, 329, 461, 461, 416, 461,
  461, 461, 461, 461, 461,

  461, 461, 461, 461, 461, 462, 462, 415, 462, 462, 462, 581, 414, 581, 581, 413, 581, 581, 581,
  215, 412, 215, 215, 411, 215, 215, 215, 468, 410, 468, 468, 409, 468, 468, 468, 338, 338, 408,
  338, 338, 338, 470, 407, 470, 470, 406, 470, 470, 470, 583, 583, 405, 583, 583, 583, 471, 471,
  404, 471, 471, 471, 472, 472, 403, 472, 472, 472, 475, 402, 475, 475, 401, 475, 475, 475, 476,
  476, 400, 476, 476, 476, 477, 477, 399, 477, 477, 477, 117, 117, 398, 117, 117, 117, 587, 587,
  397, 587, 587, 587, 435,

  435, 396, 435, 435, 435, 435, 435, 435, 435, 435, 435, 435, 435, 557, 557, 395, 557, 557, 557,
  557, 557, 557, 557, 557, 557, 557, 557, 658, 658, 394, 658, 658, 658, 658, 658, 658, 658, 658,
  658, 658, 658, 659, 659, 393, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 659, 312, 312,
  392, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 563, 563, 391, 563, 563, 563, 563,
  563, 563, 563, 563, 563, 563, 563, 564, 564, 390, 564, 564, 564, 564, 564, 564, 564, 564, 564,
  564, 564, 565, 565, 389,

  565, 565, 565, 565, 565, 565, 565, 565, 565, 565, 565, 568, 568, 388, 568, 568, 568, 199, 199,
  199, 199, 199, 199, 209, 387, 209, 209, 386, 209, 209, 209, 336, 385, 336, 336, 384, 336, 336,
  336, 581, 383, 581, 581, 382, 581, 581, 581, 462, 462, 381, 462, 462, 462, 215, 378, 215, 215,
  377, 215, 215, 215, 583, 583, 376, 583, 583, 583, 885, 885, 375, 885, 885, 885, 885, 885, 885,
  885, 885, 885, 885, 885, 908, 908, 374, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908, 908,
  716, 716, 716, 716, 716,

  716, 716, 716, 716, 716, 716, 373, 372, 716, 726, 726, 726, 726, 726, 726, 726, 726, 726, 726,
  726, 371, 370, 726, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 777, 369, 366, 777, 783,
  783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 365, 364, 783, 792, 792, 792, 792, 792, 792,
  792, 792, 792, 792, 792, 363, 362, 792, 945, 945, 361, 945, 945, 945, 945, 945, 945, 945, 945,
  945, 945, 945, 953, 953, 360, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 866, 866,
  866, 866, 866, 866, 866,

  866, 866, 866, 866, 359, 233, 866, 965, 965, 358, 965, 965, 965, 965, 965, 965, 965, 965, 965,
  965, 965, 966, 966, 357, 966, 966, 966, 966, 966, 966, 966, 966, 966, 966, 966, 356, 355, 333,
  332, 321, 200, 320, 192, 195, 192, 307, 306, 305, 302, 301, 298, 297, 296, 295, 291, 288, 285,
  282, 281, 280, 279, 276, 275, 274, 273, 272, 269, 268, 265, 264, 263, 257, 256, 255, 254, 253,
  252, 251, 250, 240, 239, 238, 237, 129, 234, 233, 231, 230, 125, 76, 229, 228, 227, 226, 206, 205,
  200, 197, 196, 195,

  192, 183, 182, 167, 157, 156, 131, 126, 125, 119, 118, 114, 85, 76, 66, 967, 3, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967,

  967, 967, 967, 967, 967, 967, 967, 967, 967 };

static const flex_int16_t yy_chk[2910] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 5, 2, 2, 9, 5, 2,

  10, 11, 10, 10, 13, 13, 17, 13, 13, 16, 2, 19, 22, 13, 30, 22, 19, 13, 25, 25, 17, 17, 11, 29, 2,
  16, 43, 29, 19, 35, 23, 35, 50, 30, 18, 50, 43, 13, 18, 13, 18, 18, 18, 18, 18, 18, 18, 18, 18, 9,
  23, 23, 23, 34, 34, 58, 34, 34, 13, 32, 39, 41, 39, 32, 44, 13, 20, 29, 41, 39, 44, 41, 202, 20,
  41, 20, 20, 20, 20, 20, 20, 20, 20, 20, 40, 21, 45, 80, 202, 40, 20, 45, 21, 20, 21, 21, 21, 21,
  21, 21,

  21, 21, 21, 32, 67, 48, 42, 80, 38, 48, 34, 20, 21, 58, 38, 42, 65, 75, 48, 20, 65, 38, 20, 38,
  48, 42, 49, 38, 49, 49, 84, 54, 52, 52, 53, 54, 38, 53, 76, 55, 20, 21, 52, 52, 55, 63, 53, 76,
  151, 55, 63, 54, 151, 53, 59, 59, 67, 59, 59, 82, 83, 59, 63, 84, 82, 75, 94, 77, 77, 95, 77, 77,
  59, 83, 94, 54, 77, 120, 93, 167, 77, 167, 95, 101, 101, 323, 59, 93, 93, 93, 93, 93, 93, 93, 93,
  93, 146, 146, 165, 54,

  77, 323, 77, 165, 54, 93, 97, 97, 97, 97, 97, 97, 97, 97, 97, 132, 147, 154, 160, 147, 242, 77,
  177, 132, 147, 154, 169, 242, 77, 120, 171, 177, 160, 171, 93, 98, 98, 98, 98, 98, 98, 98, 98, 98,
  169, 99, 171, 180, 203, 180, 195, 195, 99, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 189, 100, 313,
  203, 315, 189, 315, 201, 100, 99, 100, 100, 100, 100, 100, 100, 100, 100, 100, 98, 201, 313, 891,
  176, 102, 892, 102, 176, 100, 102, 102, 102, 102, 102, 102, 102, 102,

  102, 99, 104, 104, 104, 104, 104, 104, 104, 104, 104, 321, 105, 127, 127, 321, 127, 127, 449, 105,
  100, 105, 105, 105, 105, 105, 105, 105, 105, 105, 176, 192, 383, 192, 383, 107, 449, 107, 204,
  105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 137, 893, 137, 137, 193, 137, 186, 186, 137,
  186, 186, 310, 193, 186, 137, 197, 137, 137, 137, 105, 197, 127, 194, 194, 186, 204, 294, 308,
  204, 324, 319, 253, 326, 220, 324, 308, 194, 294, 186, 192, 204, 204, 220, 220, 253, 328, 325,
  343, 343, 894, 194,

  207, 207, 207, 207, 207, 207, 207, 207, 207, 296, 322, 424, 438, 208, 438, 326, 327, 310, 296,
  322, 424, 197, 208, 208, 208, 208, 208, 208, 208, 208, 208, 319, 325, 414, 436, 328, 210, 414,
  210, 325, 208, 210, 210, 210, 210, 210, 210, 210, 210, 210, 214, 439, 450, 436, 451, 453, 439,
  571, 450, 214, 214, 214, 214, 214, 214, 214, 214, 214, 327, 208, 571, 895, 896, 216, 451, 216,
  454, 214, 216, 216, 216, 216, 216, 216, 216, 216, 216, 218, 452, 218, 456, 455, 218, 218, 218,
  218, 218, 218, 218, 218,

  218, 719, 897, 719, 898, 453, 214, 219, 219, 219, 219, 219, 219, 219, 219, 219, 221, 221, 221,
  221, 221, 221, 221, 221, 221, 222, 452, 454, 455, 572, 574, 900, 456, 901, 222, 222, 222, 222,
  222, 222, 222, 222, 222, 223, 508, 555, 570, 573, 575, 508, 555, 570, 223, 223, 223, 223, 223,
  223, 223, 223, 223, 569, 576, 225, 665, 572, 223, 223, 223, 223, 223, 223, 225, 225, 225, 225,
  225, 225, 225, 225, 225, 344, 574, 573, 575, 569, 665, 309, 309, 745, 344, 344, 902, 904, 906,
  223, 223, 223, 223, 223,

  223, 309, 330, 330, 330, 330, 330, 330, 330, 330, 330, 331, 666, 576, 668, 309, 751, 745, 753,
  666, 331, 331, 331, 331, 331, 331, 331, 331, 331, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  335, 631, 631, 820, 631, 631, 746, 907, 909, 335, 335, 335, 335, 335, 335, 335, 335, 335, 669,
  671, 668, 746, 751, 337, 753, 337, 910, 335, 337, 337, 337, 337, 337, 337, 337, 337, 337, 339,
  339, 339, 339, 339, 339, 339, 339, 339, 539, 820, 340, 911, 539, 539, 669, 671, 912, 539, 335,
  340, 340, 340, 340, 340,

  340, 340, 340, 340, 342, 710, 710, 913, 710, 710, 914, 821, 822, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 346, 346, 346, 346, 346, 346, 346, 346, 346, 347, 670, 752, 672, 712, 712, 754,
  712, 712, 347, 347, 347, 347, 347, 347, 347, 347, 347, 350, 785, 785, 823, 785, 785, 821, 822,
  915, 350, 350, 350, 350, 350, 350, 350, 350, 350, 752, 670, 353, 672, 754, 350, 350, 350, 350,
  350, 350, 353, 353, 353, 353, 353, 353, 353, 353, 353, 458, 458, 458, 458, 458, 458, 458, 458,
  458, 823, 918, 919, 642,

  921, 350, 350, 350, 350, 350, 350, 351, 642, 642, 922, 924, 929, 930, 712, 932, 351, 351, 351,
  351, 351, 351, 351, 351, 351, 933, 937, 457, 940, 785, 351, 351, 351, 351, 351, 351, 457, 457,
  457, 457, 457, 457, 457, 457, 457, 463, 463, 463, 463, 463, 463, 463, 463, 463, 715, 715, 459,
  715, 715, 351, 351, 351, 351, 351, 351, 459, 459, 459, 459, 459, 459, 459, 459, 459, 464, 837,
  837, 942, 837, 837, 858, 859, 715, 464, 464, 464, 464, 464, 464, 464, 464, 464, 465, 790, 790,
  944, 790, 790, 946, 947,

  950, 465, 465, 465, 465, 465, 465, 465, 465, 465, 466, 466, 466, 466, 466, 466, 466, 466, 466,
  467, 951, 790, 954, 955, 858, 859, 956, 958, 467, 467, 467, 467, 467, 467, 467, 467, 467, 469,
  869, 869, 959, 869, 869, 890, 888, 887, 469, 469, 469, 469, 469, 469, 469, 469, 469, 473, 886,
  884, 883, 881, 880, 879, 878, 877, 473, 473, 473, 473, 473, 473, 473, 473, 473, 876, 875, 577,
  874, 873, 473, 473, 473, 473, 473, 473, 577, 577, 577, 577, 577, 577, 577, 577, 577, 579, 579,
  579, 579, 579, 579, 579,

  579, 579, 747, 747, 872, 747, 747, 473, 473, 473, 473, 473, 473, 474, 871, 747, 870, 869, 868,
  865, 863, 861, 474, 474, 474, 474, 474, 474, 474, 474, 474, 920, 920, 578, 920, 920, 474, 474,
  474, 474, 474, 474, 578, 578, 578, 578, 578, 578, 578, 578, 578, 818, 818, 860, 818, 818, 857,
  936, 936, 920, 936, 936, 580, 856, 818, 474, 474, 474, 474, 474, 474, 580, 580, 580, 580, 580,
  580, 580, 580, 580, 582, 855, 854, 852, 851, 936, 850, 849, 848, 582, 582, 582, 582, 582, 582,
  582, 582, 582, 636, 636,

  636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636,
  636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 667, 667, 847, 667, 667, 673,
  938, 938, 846, 938, 938, 845, 844, 667, 673, 673, 673, 673, 673, 673, 673, 673, 673, 843, 636,
  636, 636, 636, 667, 842, 841, 840, 839, 838, 938, 836, 833, 831, 830, 829, 828, 827, 826, 825,
  815, 814, 813, 812, 667, 811, 810, 809, 808, 807, 636, 636, 636, 636, 643, 643, 643, 643, 643,
  643, 643, 643, 643, 643,

  643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643, 643,
  643, 643, 643, 643, 643, 750, 750, 803, 750, 750, 816, 816, 801, 816, 816, 800, 948, 948, 750,
  948, 948, 957, 957, 816, 957, 957, 799, 798, 797, 643, 643, 643, 643, 750, 796, 795, 794, 789,
  816, 787, 786, 781, 779, 775, 948, 773, 772, 769, 768, 957, 767, 765, 764, 763, 762, 761, 760,
  756, 816, 643, 643, 643, 643, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703,
  703, 703, 703, 703, 703,

  703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 703, 817, 817, 755,
  817, 817, 961, 961, 749, 961, 961, 744, 743, 742, 817, 741, 740, 739, 738, 737, 735, 734, 732,
  731, 729, 703, 703, 703, 703, 817, 728, 725, 724, 723, 961, 722, 721, 720, 714, 713, 711, 708,
  707, 706, 705, 702, 701, 699, 698, 817, 697, 696, 695, 693, 692, 703, 703, 703, 703, 709, 709,
  709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709,
  709, 709, 709, 709, 709,

  709, 709, 709, 709, 709, 709, 709, 709, 691, 690, 688, 687, 686, 684, 683, 681, 680, 678, 676,
  675, 674, 664, 663, 662, 661, 660, 657, 656, 655, 653, 652, 651, 709, 709, 709, 709, 650, 649,
  648, 647, 646, 645, 641, 640, 639, 638, 637, 634, 633, 632, 630, 629, 628, 627, 626, 624, 623,
  622, 621, 617, 616, 613, 709, 709, 709, 709, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718,
  718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718, 718,
  718, 718, 718, 718, 718,

  612, 611, 610, 609, 608, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592,
  591, 590, 589, 588, 586, 718, 718, 718, 718, 585, 584, 567, 566, 562, 561, 560, 556, 554, 553,
  552, 551, 550, 548, 546, 545, 543, 542, 541, 540, 538, 537, 536, 535, 534, 532, 718, 718, 718,
  718, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835,
  835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 835, 531, 530, 529,
  528, 527, 525, 524, 523,

  522, 521, 520, 519, 518, 517, 515, 514, 513, 512, 511, 510, 509, 505, 504, 501, 835, 835, 835,
  835, 500, 499, 498, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 485, 484, 483,
  482, 480, 479, 478, 446, 445, 440, 433, 835, 835, 835, 835, 968, 968, 968, 968, 968, 968, 968,
  968, 968, 968, 968, 968, 968, 968, 969, 969, 969, 969, 969, 969, 432, 969, 969, 969, 969, 969,
  969, 969, 970, 970, 431, 970, 970, 430, 428, 427, 426, 425, 970, 970, 970, 971, 971, 971, 971,
  423, 971, 971, 971, 972,

  972, 422, 972, 972, 972, 973, 973, 421, 973, 973, 973, 973, 973, 973, 973, 973, 973, 973, 973,
  974, 974, 974, 974, 974, 974, 975, 420, 975, 975, 419, 975, 975, 975, 976, 976, 418, 976, 976,
  976, 976, 976, 976, 976, 976, 976, 976, 976, 977, 977, 417, 977, 977, 977, 978, 978, 978, 978,
  416, 978, 978, 978, 979, 979, 415, 979, 980, 980, 413, 980, 980, 980, 981, 412, 411, 410, 981,
  981, 981, 981, 981, 981, 981, 981, 981, 981, 982, 982, 409, 982, 982, 982, 982, 982, 982, 982,
  982, 982, 982, 982, 983,

  983, 983, 984, 984, 408, 984, 984, 984, 985, 407, 985, 985, 406, 985, 985, 985, 986, 986, 405,
  986, 986, 986, 987, 987, 404, 987, 987, 987, 988, 403, 988, 402, 401, 988, 988, 988, 989, 400,
  989, 989, 398, 989, 989, 989, 990, 397, 990, 990, 396, 990, 990, 990, 991, 395, 991, 991, 394,
  991, 991, 991, 992, 992, 393, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 993, 993,
  391, 993, 993, 993, 993, 993, 993, 993, 993, 993, 993, 993, 994, 994, 390, 994, 994, 994, 995,
  995, 995, 996, 389, 388,

  387, 386, 385, 996, 996, 996, 997, 997, 997, 997, 997, 997, 998, 384, 998, 998, 382, 998, 998,
  998, 999, 999, 380, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 1000, 379, 1000, 1000,
  377, 1000, 1000, 1000, 1001, 1001, 376, 1001, 1001, 1001, 1002, 1002, 375, 1002, 1002, 1002, 1003,
  374, 1003, 1003, 373, 1003, 1003, 1003, 1004, 1004, 372, 1004, 1004, 1004, 1005, 371, 1005, 1005,
  370, 1005, 1005, 1005, 1006, 369, 1006, 368, 367, 1006, 1006, 1006, 1007, 1007, 366, 1007, 1007,
  1007, 1008, 365, 1008, 1008, 364, 1008, 1008, 1008, 1009, 1009,

  363, 1009, 1009, 1009, 1010, 1010, 362, 1010, 1011, 361, 1011, 1011, 360, 1011, 1011, 1011, 1012,
  359, 1012, 1012, 357, 1012, 1012, 1012, 1013, 1013, 356, 1013, 1013, 1013, 1014, 355, 1014, 1014,
  317, 1014, 1014, 1014, 1015, 1015, 316, 1015, 1015, 1015, 1016, 1016, 314, 1016, 1016, 1016, 1017,
  1017, 1017, 1018, 1018, 311, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018,
  1019, 1019, 307, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1020, 1020,
  306, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1020, 1021, 1021, 305, 1021,
  1021,

  1021, 1021, 1021, 1021, 1021, 1021, 1021, 1021, 1021, 1022, 1022, 304, 1022, 1022, 1022, 1022,
  1022, 1022, 1022, 1022, 1022, 1022, 1022, 1023, 1023, 303, 1023, 1023, 1023, 1023, 1023, 1023,
  1023, 1023, 1023, 1023, 1023, 1024, 1024, 302, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  1024, 1024, 1024, 1025, 1025, 301, 1025, 1025, 1025, 1026, 1026, 300, 1026, 1026, 1026, 1027,
  1027, 1027, 1027, 1027, 1027, 1028, 299, 1028, 1028, 298, 1028, 1028, 1028, 1029, 295, 1029, 1029,
  293, 1029, 1029, 1029, 1030, 1030, 292, 1030, 1030, 1030, 1031, 1031, 291, 1031, 1031, 1031, 1031,
  1031, 1031,

  1031, 1031, 1031, 1031, 1031, 1032, 1032, 290, 1032, 1032, 1032, 1033, 289, 1033, 1033, 288, 1033,
  1033, 1033, 1034, 287, 1034, 1034, 286, 1034, 1034, 1034, 1035, 285, 1035, 1035, 284, 1035, 1035,
  1035, 1036, 1036, 283, 1036, 1036, 1036, 1037, 282, 1037, 1037, 281, 1037, 1037, 1037, 1038, 1038,
  280, 1038, 1038, 1038, 1039, 1039, 279, 1039, 1039, 1039, 1040, 1040, 278, 1040, 1040, 1040, 1041,
  277, 1041, 1041, 275, 1041, 1041, 1041, 1042, 1042, 274, 1042, 1042, 1042, 1043, 1043, 273, 1043,
  1043, 1043, 1044, 1044, 272, 1044, 1044, 1044, 1045, 1045, 270, 1045, 1045, 1045, 1046,

  1046, 269, 1046, 1046, 1046, 1046, 1046, 1046, 1046, 1046, 1046, 1046, 1046, 1047, 1047, 268,
  1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1048, 1048, 267, 1048, 1048,
  1048, 1048, 1048, 1048, 1048, 1048, 1048, 1048, 1048, 1049, 1049, 266, 1049, 1049, 1049, 1049,
  1049, 1049, 1049, 1049, 1049, 1049, 1049, 1050, 1050, 265, 1050, 1050, 1050, 1050, 1050, 1050,
  1050, 1050, 1050, 1050, 1050, 1051, 1051, 264, 1051, 1051, 1051, 1051, 1051, 1051, 1051, 1051,
  1051, 1051, 1051, 1052, 1052, 263, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052, 1052,
  1052, 1053, 1053, 262,

  1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1053, 1054, 1054, 261, 1054, 1054,
  1054, 1055, 1055, 1055, 1055, 1055, 1055, 1056, 260, 1056, 1056, 259, 1056, 1056, 1056, 1057, 258,
  1057, 1057, 257, 1057, 1057, 1057, 1058, 256, 1058, 1058, 255, 1058, 1058, 1058, 1059, 1059, 254,
  1059, 1059, 1059, 1060, 252, 1060, 1060, 251, 1060, 1060, 1060, 1061, 1061, 250, 1061, 1061, 1061,
  1062, 1062, 249, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1063, 1063,
  248, 1063, 1063, 1063, 1063, 1063, 1063, 1063, 1063, 1063, 1063, 1063, 1064, 1064, 1064, 1064,
  1064,

  1064, 1064, 1064, 1064, 1064, 1064, 247, 246, 1064, 1065, 1065, 1065, 1065, 1065, 1065, 1065,
  1065, 1065, 1065, 1065, 245, 244, 1065, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066,
  1066, 1066, 243, 241, 1066, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 240,
  239, 1067, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 238, 237, 1068, 1069,
  1069, 236, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1069, 1070, 1070, 235,
  1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1070, 1071, 1071, 1071, 1071, 1071,
  1071, 1071,

  1071, 1071, 1071, 1071, 234, 232, 1071, 1072, 1072, 231, 1072, 1072, 1072, 1072, 1072, 1072, 1072,
  1072, 1072, 1072, 1072, 1073, 1073, 230, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073,
  1073, 1073, 229, 228, 213, 211, 200, 199, 198, 191, 190, 188, 183, 182, 181, 179, 178, 175, 174,
  173, 172, 170, 168, 166, 164, 163, 162, 161, 159, 158, 157, 156, 155, 153, 152, 150, 149, 148,
  145, 144, 143, 142, 141, 140, 139, 138, 136, 135, 134, 133, 130, 126, 125, 124, 123, 122, 121,
  119, 118, 116, 112, 92, 90, 81, 69, 68, 64,

  62, 57, 56, 51, 47, 46, 37, 33, 31, 28, 26, 24, 15, 12, 8, 3, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967,

  967, 967, 967, 967, 967, 967, 967, 967, 967 };

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[166] = {
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
};

static yy_state_type yy_last_accepting_state;
static char* yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char* yytext;

/*

This file must be translated to C and modified to build everywhere.

See the adjacent README.txt file for instructions.

*/

/* to workaround https://bugs.llvm.org/show_bug.cgi?id=43465 */
#if defined(__clang__)
#pragma clang diagnostic push
#if defined(__has_warning)
#if __has_warning("-Wimplicit-fallthrough")
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#endif
#endif
#elif defined(__GNUC__) && (__GNUC__ >= 7)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#endif

/* We do not care of interactive mode */
#define YY_NEVER_INTERACTIVE 1

/* Do not include unistd.h in generated source. */
#define YY_NO_UNISTD_H

/* Skip declaring this function.  It is a macro.  */
#define YY_SKIP_YYWRAP

#ifdef _WIN32
#pragma warning(disable : 4018)
#pragma warning(disable : 4127)
#pragma warning(disable : 4131)
#pragma warning(disable : 4244)
#pragma warning(disable : 4251)
#pragma warning(disable : 4267)
#pragma warning(disable : 4305)
#pragma warning(disable : 4309)
#pragma warning(disable : 4706)
#pragma warning(disable : 4786)
#endif

#define SKIP_MATCH_MAXLEN 15

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 * Return 0 if no match found.
 */
static int skip_comment(void);
static int skip_trailing_comment(const char* text, size_t l);
static int skip_ahead_multi(const char* strings[]);
static int skip_ahead_until(const char* text);
static int skip_to_next_directive(void);
static int skip_conditional_block(void);

static void doxygen_comment(void);
static void doxygen_cpp_comment(void);
static void doxygen_group_start(void);
static void doxygen_group_end(void);
static void vtk_comment(void);
static void vtk_name_comment(void);
static void vtk_section_comment(void);
static void cpp_comment_line(void);
static void blank_line(void);

static const char* raw_string(const char* begin);

static void preprocessor_directive(const char* text, size_t l);
static void print_preprocessor_error(int result, const char* cp, size_t n);
static char* get_macro_arguments(void);
static void skip_macro_arguments(void);

static void push_buffer(void);
static int pop_buffer(void);

static void push_include(const char* filename);
static void pop_include(void);

static void push_macro(MacroInfo* macro);
static void pop_macro(void);
static int in_macro(void);

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void*
#endif

static int yy_init_globals(void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(void);

int yyget_debug(void);

void yyset_debug(int debug_flag);

YY_EXTRA_TYPE yyget_extra(void);

void yyset_extra(YY_EXTRA_TYPE user_defined);

FILE* yyget_in(void);

void yyset_in(FILE* _in_str);

FILE* yyget_out(void);

void yyset_out(FILE* _out_str);

int yyget_leng(void);

char* yyget_text(void);

int yyget_lineno(void);

void yyset_lineno(int _line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap(void);
#else
extern int yywrap(void);
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* buf_ptr);

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char*, const char*, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char*);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void);
#else
static int input(void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                                       \
  do                                                                                               \
  {                                                                                                \
    if (fwrite(yytext, (size_t)yyleng, 1, yyout))                                                  \
    {                                                                                              \
    }                                                                                              \
  } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                            \
  if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive)                                                 \
  {                                                                                                \
    int c = '*';                                                                                   \
    int n;                                                                                         \
    for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)                         \
      buf[n] = (char)c;                                                                            \
    if (c == '\n')                                                                                 \
      buf[n++] = (char)c;                                                                          \
    if (c == EOF && ferror(yyin))                                                                  \
      YY_FATAL_ERROR("input in flex scanner failed");                                              \
    result = n;                                                                                    \
  }                                                                                                \
  else                                                                                             \
  {                                                                                                \
    errno = 0;                                                                                     \
    while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && ferror(yyin))          \
    {                                                                                              \
      if (errno != EINTR)                                                                          \
      {                                                                                            \
        YY_FATAL_ERROR("input in flex scanner failed");                                            \
        break;                                                                                     \
      }                                                                                            \
      errno = 0;                                                                                   \
      clearerr(yyin);                                                                              \
    }                                                                                              \
  }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex(void);

#define YY_DECL int yylex(void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP                                                                              \
  if (yyleng > 0)                                                                                  \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (yytext[yyleng - 1] == '\n');                            \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;

  if (!(yy_init))
  {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start))
      (yy_start) = 1; /* first start state */

    if (!yyin)
      yyin = stdin;

    if (!yyout)
      yyout = stdout;

    if (!YY_CURRENT_BUFFER)
    {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  {

    while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
    {
      yy_cp = (yy_c_buf_p);

      /* Support of yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
      yy_current_state += YY_AT_BOL();
    yy_match:
      do
      {
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state])
        {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 968)
            yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        ++yy_cp;
      } while (yy_base[yy_current_state] != 2817);

    yy_find_action:
      yy_act = yy_accept[yy_current_state];
      if (yy_act == 0)
      { /* have to back up */
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act = yy_accept[yy_current_state];
      }

      YY_DO_BEFORE_ACTION;

      if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act])
      {
        int yyl;
        for (yyl = 0; yyl < yyleng; ++yyl)
          if (yytext[yyl] == '\n')

            yylineno++;
        ;
      }

    do_action: /* This label is used only to access EOF actions. */

      switch (yy_act)
      {         /* beginning of action switch */
        case 0: /* must back up */
          /* undo the effects of YY_DO_BEFORE_ACTION */
          *yy_cp = (yy_hold_char);
          yy_cp = (yy_last_accepting_cpos);
          yy_current_state = (yy_last_accepting_state);
          goto yy_find_action;

        case 1:
          YY_RULE_SETUP { doxygen_comment(); }
          YY_BREAK
        case 2:
          YY_RULE_SETUP { doxygen_comment(); }
          YY_BREAK
        case 3:
          YY_RULE_SETUP { skip_comment(); }
          YY_BREAK
        case 4:
          YY_RULE_SETUP { skip_ahead_until("@end"); }
          YY_BREAK
        case 5:
          YY_RULE_SETUP { doxygen_cpp_comment(); }
          YY_BREAK
        case 6:
          YY_RULE_SETUP { doxygen_cpp_comment(); }
          YY_BREAK
        case 7:
          YY_RULE_SETUP { doxygen_group_start(); }
          YY_BREAK
        case 8:
          YY_RULE_SETUP { doxygen_group_end(); }
          YY_BREAK
        case 9:
          YY_RULE_SETUP { vtk_comment(); }
          YY_BREAK
        case 10:
          YY_RULE_SETUP { vtk_name_comment(); }
          YY_BREAK
        case 11:
          YY_RULE_SETUP { vtk_section_comment(); }
          YY_BREAK
        case 12:
          YY_RULE_SETUP { cpp_comment_line(); }
          YY_BREAK
        case 13:
          /* rule 13 can match eol */
          YY_RULE_SETUP { blank_line(); }
          YY_BREAK
        case 14:
          YY_RULE_SETUP
          /* eat trailing C++ comments */
          YY_BREAK
        case 15:
          /* rule 15 can match eol */
          YY_RULE_SETUP
          {
            skip_trailing_comment(yytext, yyleng);
            preprocessor_directive(yytext, yyleng);
          }
          YY_BREAK
        case 16:
          /* rule 16 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (STRING_LITERAL);
          }
          YY_BREAK
        case 17:
          /* rule 17 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (CHAR_LITERAL);
          }
          YY_BREAK
        case 18:
          YY_RULE_SETUP
          {
            yylval.str = raw_string(yytext);
            return (STRING_LITERAL);
          }
          YY_BREAK
        case 19:
          YY_RULE_SETUP
          return (AUTO);
          YY_BREAK
        case 20:
          YY_RULE_SETUP
          return (DOUBLE);
          YY_BREAK
        case 21:
          YY_RULE_SETUP
          return (FLOAT);
          YY_BREAK
        case 22:
          YY_RULE_SETUP
          return (INT64__);
          YY_BREAK
        case 23:
          YY_RULE_SETUP
          return (SHORT);
          YY_BREAK
        case 24:
          YY_RULE_SETUP
          return (LONG);
          YY_BREAK
        case 25:
          YY_RULE_SETUP
          return (CHAR);
          YY_BREAK
        case 26:
          YY_RULE_SETUP
          return (INT);
          YY_BREAK
        case 27:
          YY_RULE_SETUP
          return (UNSIGNED);
          YY_BREAK
        case 28:
          YY_RULE_SETUP
          return (SIGNED);
          YY_BREAK
        case 29:
          YY_RULE_SETUP
          return (VOID);
          YY_BREAK
        case 30:
          YY_RULE_SETUP
          return (BOOL);
          YY_BREAK
        case 31:
          YY_RULE_SETUP
          return (CHAR16_T);
          YY_BREAK
        case 32:
          YY_RULE_SETUP
          return (CHAR32_T);
          YY_BREAK
        case 33:
          YY_RULE_SETUP
          return (WCHAR_T);
          YY_BREAK
        case 34:
          /* rule 34 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::size_t" : "size_t");
            return (SIZE_T);
          }
          YY_BREAK
        case 35:
          /* rule 35 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::ssize_t" : "ssize_t");
            return (SSIZE_T);
          }
          YY_BREAK
        case 36:
          /* rule 36 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::nullptr_t" : "nullptr_t");
            return (NULLPTR_T);
          }
          YY_BREAK
        case 37:
          YY_RULE_SETUP
          /* ignore the Q_OBJECT macro from Qt */
          YY_BREAK
        case 38:
          /* rule 38 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 39:
          /* rule 39 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 40:
          /* rule 40 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 41:
          /* rule 41 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 42:
          YY_RULE_SETUP
          return (CLASS);
          YY_BREAK
        case 43:
          YY_RULE_SETUP
          return (STRUCT);
          YY_BREAK
        case 44:
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 45:
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 46:
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 47:
          YY_RULE_SETUP
          return (ENUM);
          YY_BREAK
        case 48:
          YY_RULE_SETUP
          return (UNION);
          YY_BREAK
        case 49:
          YY_RULE_SETUP
          return (VIRTUAL);
          YY_BREAK
        case 50:
          YY_RULE_SETUP
          return (CONST);
          YY_BREAK
        case 51:
          YY_RULE_SETUP
          return (VOLATILE);
          YY_BREAK
        case 52:
          YY_RULE_SETUP
          return (MUTABLE);
          YY_BREAK
        case 53:
          YY_RULE_SETUP
          return (OPERATOR);
          YY_BREAK
        case 54:
          YY_RULE_SETUP
          return (FRIEND);
          YY_BREAK
        case 55:
          YY_RULE_SETUP
          return (INLINE);
          YY_BREAK
        case 56:
          YY_RULE_SETUP
          return (CONSTEXPR);
          YY_BREAK
        case 57:
          YY_RULE_SETUP
          return (STATIC);
          YY_BREAK
        case 58:
          YY_RULE_SETUP
          return (THREAD_LOCAL);
          YY_BREAK
        case 59:
          YY_RULE_SETUP
          return (EXTERN);
          YY_BREAK
        case 60:
          YY_RULE_SETUP
          return (TEMPLATE);
          YY_BREAK
        case 61:
          YY_RULE_SETUP
          return (TYPENAME);
          YY_BREAK
        case 62:
          YY_RULE_SETUP
          return (TYPEDEF);
          YY_BREAK
        case 63:
          YY_RULE_SETUP
          return (NAMESPACE);
          YY_BREAK
        case 64:
          YY_RULE_SETUP
          return (USING);
          YY_BREAK
        case 65:
          YY_RULE_SETUP
          return (NEW);
          YY_BREAK
        case 66:
          YY_RULE_SETUP
          return (DELETE);
          YY_BREAK
        case 67:
          YY_RULE_SETUP
          return (EXPLICIT);
          YY_BREAK
        case 68:
          YY_RULE_SETUP
          return (THROW);
          YY_BREAK
        case 69:
          YY_RULE_SETUP
          return (TRY);
          YY_BREAK
        case 70:
          YY_RULE_SETUP
          return (CATCH);
          YY_BREAK
        case 71:
          YY_RULE_SETUP
          return (NOEXCEPT);
          YY_BREAK
        case 72:
          YY_RULE_SETUP
          return (DECLTYPE);
          YY_BREAK
        case 73:
          YY_RULE_SETUP
          return (DEFAULT);
          YY_BREAK
        case 74:
          YY_RULE_SETUP
          return (STATIC_CAST);
          YY_BREAK
        case 75:
          YY_RULE_SETUP
          return (DYNAMIC_CAST);
          YY_BREAK
        case 76:
          YY_RULE_SETUP
          return (CONST_CAST);
          YY_BREAK
        case 77:
          YY_RULE_SETUP
          return (REINTERPRET_CAST);
          YY_BREAK
        case 78:
          YY_RULE_SETUP
          /* irrelevant to wrappers */
          YY_BREAK
        case 79:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 80:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 81:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 82:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 83:
          YY_RULE_SETUP
          return ('!');
          YY_BREAK
        case 84:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 85:
          YY_RULE_SETUP
          return ('^');
          YY_BREAK
        case 86:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 87:
          YY_RULE_SETUP
          return ('&');
          YY_BREAK
        case 88:
          YY_RULE_SETUP
          return ('|');
          YY_BREAK
        case 89:
          YY_RULE_SETUP
          return ('~');
          YY_BREAK
        case 90:
          /* rule 90 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '&')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LA);
          }
          YY_BREAK
        case 91:
          /* rule 91 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '*')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LP);
          }
          YY_BREAK
        case 92:
          /* rule 92 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 93:
          /* rule 93 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 94:
          /* rule 94 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 95:
          YY_RULE_SETUP
          return ('*');
          YY_BREAK
        case 96:
          YY_RULE_SETUP
          /* misc unused win32 macros */
          YY_BREAK
        case 97:
          /* rule 97 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OSTREAM);
          }
          YY_BREAK
        case 98:
          /* rule 98 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ISTREAM);
          }
          YY_BREAK
        case 99:
          /* rule 99 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 100:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 101:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (QT_ID);
          }
          YY_BREAK
        case 102:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C++11 */
          YY_BREAK
        case 103:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C++11 */
          YY_BREAK
        case 104:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C11 */
          YY_BREAK
        case 105:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C11 */
          YY_BREAK
        case 106:
          YY_RULE_SETUP
          return (THREAD_LOCAL); /* C11 */
          YY_BREAK
        case 107:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 108:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 109:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C99 */
          YY_BREAK
        case 110:
          YY_RULE_SETUP
          skip_macro_arguments(); /* MSVC */
          YY_BREAK
        case 111:
          YY_RULE_SETUP
          skip_macro_arguments(); /* gcc attributes */
          YY_BREAK
        case 112:
          YY_RULE_SETUP
          skip_macro_arguments(); /* Windows linkage */
          YY_BREAK
        case 113:
          YY_RULE_SETUP
          /* Windows */
          YY_BREAK
        case 114:
          YY_RULE_SETUP
          /* gcc/clang/other extension */
          YY_BREAK
        case 115:
          YY_RULE_SETUP
          /* MSVC extension */
          YY_BREAK
        case 116:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (NULLPTR);
          }
          YY_BREAK
        case 117:
          YY_RULE_SETUP
          {
            const char* name = vtkstrndup(yytext, yyleng);
            MacroInfo* macro = vtkParsePreprocess_GetMacro(preprocessor, name);
            int expanded = 0;
            if (macro)
            {
              char* args = NULL;
              const char* emacro = NULL;

              if (macro->IsFunction)
              {
                args = get_macro_arguments();
                if (args)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, args);
                  if (!emacro)
                  {
                    print_preprocessor_error(VTK_PARSE_MACRO_NUMARGS, NULL, 0);
                    exit(1);
                  }
                  free(args);
                }
              }
              else if (macro->Definition && macro->Definition[0])
              {
                /* first see if macro evaluates to a constant value */
                preproc_int_t val;
                int is_unsigned;
                int r;
                macro->IsExcluded = 1;
                r = vtkParsePreprocess_EvaluateExpression(
                  preprocessor, macro->Definition, &val, &is_unsigned);
                macro->IsExcluded = 0;
                /* if it isn't a constant expression, then expand it */
                if (r >= VTK_PARSE_MACRO_UNDEFINED)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, NULL);
                  if (!emacro)
                  {
                    print_preprocessor_error(r, NULL, 0);
                    exit(1);
                  }
                }
              }
              else
              {
                /* macros with no definition expand to nothing */
                expanded = 1;
              }
              if (emacro)
              {
                /* invoke the parser on any expanded macros */
                push_macro(macro);
                push_buffer();
                yy_switch_to_buffer(yy_scan_string(emacro));
                vtkParsePreprocess_FreeMacroExpansion(preprocessor, macro, emacro);
                expanded = 1;
              }
            }
            if (!expanded)
            {
              /* if no macro expansion occurred, return the ID */
              yylval.str = name;
              if (yyleng > 3 && name[0] == 'v' && name[1] == 't' && name[2] == 'k')
              {
                return (VTK_ID);
              }
              else if (name[0] == 'Q')
              {
                return (QT_ID);
              }
              else
              {
                return (ID);
              }
            }
          }
          YY_BREAK
        case 118:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 119:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 120:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 121:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 122:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (HEX_LITERAL);
          }
          YY_BREAK
        case 123:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (BIN_LITERAL);
          }
          YY_BREAK
        case 124:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OCT_LITERAL);
          }
          YY_BREAK
        case 125:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (INT_LITERAL);
          }
          YY_BREAK
        case 126:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ZERO);
          }
          YY_BREAK
        case 127:
          /* rule 127 can match eol */
          YY_RULE_SETUP
          /* escaped newlines */
          YY_BREAK
        case 128:
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 129:
          /* rule 129 can match eol */
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 130:
          /* rule 130 can match eol */
          YY_RULE_SETUP
          return (BEGIN_ATTRIB);
          YY_BREAK
        case 131:
          YY_RULE_SETUP
          return ('{');
          YY_BREAK
        case 132:
          YY_RULE_SETUP
          return ('}');
          YY_BREAK
        case 133:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 134:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 135:
          YY_RULE_SETUP
          return ('#');
          YY_BREAK
        case 136:
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          (yy_c_buf_p) = yy_cp = yy_bp + 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (OP_RSHIFT_A);
          YY_BREAK
        case 137:
          YY_RULE_SETUP
          return (OP_LSHIFT_EQ);
          YY_BREAK
        case 138:
          YY_RULE_SETUP
          return (OP_RSHIFT_EQ);
          YY_BREAK
        case 139:
          YY_RULE_SETUP
          return (OP_LSHIFT);
          YY_BREAK
        case 140:
          YY_RULE_SETUP
          return (OP_DOT_POINTER);
          YY_BREAK
        case 141:
          YY_RULE_SETUP
          return (OP_ARROW_POINTER);
          YY_BREAK
        case 142:
          YY_RULE_SETUP
          return (OP_ARROW);
          YY_BREAK
        case 143:
          YY_RULE_SETUP
          return (OP_INCR);
          YY_BREAK
        case 144:
          YY_RULE_SETUP
          return (OP_DECR);
          YY_BREAK
        case 145:
          YY_RULE_SETUP
          return (OP_PLUS_EQ);
          YY_BREAK
        case 146:
          YY_RULE_SETUP
          return (OP_MINUS_EQ);
          YY_BREAK
        case 147:
          YY_RULE_SETUP
          return (OP_TIMES_EQ);
          YY_BREAK
        case 148:
          YY_RULE_SETUP
          return (OP_DIVIDE_EQ);
          YY_BREAK
        case 149:
          YY_RULE_SETUP
          return (OP_REMAINDER_EQ);
          YY_BREAK
        case 150:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 151:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 152:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 153:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 154:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 155:
          YY_RULE_SETUP
          return (OP_LOGIC_EQ);
          YY_BREAK
        case 156:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 157:
          YY_RULE_SETUP
          return (OP_LOGIC_LEQ);
          YY_BREAK
        case 158:
          YY_RULE_SETUP
          return (OP_LOGIC_GEQ);
          YY_BREAK
        case 159:
          YY_RULE_SETUP
          return (ELLIPSIS);
          YY_BREAK
        case 160:
          YY_RULE_SETUP
          return (DOUBLE_COLON);
          YY_BREAK
        case 161:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 162:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 163:
          YY_RULE_SETUP
          return (yytext[0]);
          YY_BREAK
        case YY_STATE_EOF(INITIAL):
        {
          if (!pop_buffer())
          {
            yyterminate();
          }
        }
          YY_BREAK
        case 164:
          YY_RULE_SETUP { return (OTHER); }
          YY_BREAK
        case 165:
          YY_RULE_SETUP
          YY_FATAL_ERROR("flex scanner jammed");
          YY_BREAK

        case YY_END_OF_BUFFER:
        {
          /* Amount of text matched not including the EOB char. */
          int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

          /* Undo the effects of YY_DO_BEFORE_ACTION. */
          *yy_cp = (yy_hold_char);
          YY_RESTORE_YY_MORE_OFFSET

          if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
          {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between YY_CURRENT_BUFFER and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
            YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
          }

          /* Note that here we test for yy_c_buf_p "<=" to the position
           * of the first EOB in the buffer, since yy_c_buf_p will
           * already have been incremented past the NUL character
           * (since all states make transitions on EOB to the
           * end-of-buffer state).  Contrast this with the test
           * in input().
           */
          if ((yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
          { /* This was really a NUL. */
            yy_state_type yy_next_state;

            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans(yy_current_state);

            yy_bp = (yytext_ptr) + YY_MORE_ADJ;

            if (yy_next_state)
            {
              /* Consume the NUL. */
              yy_cp = ++(yy_c_buf_p);
              yy_current_state = yy_next_state;
              goto yy_match;
            }

            else
            {
              yy_cp = (yy_c_buf_p);
              goto yy_find_action;
            }
          }

          else
            switch (yy_get_next_buffer())
            {
              case EOB_ACT_END_OF_FILE:
              {
                (yy_did_buffer_switch_on_eof) = 0;

                if (yywrap())
                {
                  /* Note: because we've taken care in
                   * yy_get_next_buffer() to have set up
                   * yytext, we can now set up
                   * yy_c_buf_p so that if some total
                   * hoser (like flex itself) wants to
                   * call the scanner after we return the
                   * YY_NULL, it'll still work - another
                   * YY_NULL will get returned.
                   */
                  (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                  yy_act = YY_STATE_EOF(YY_START);
                  goto do_action;
                }

                else
                {
                  if (!(yy_did_buffer_switch_on_eof))
                    YY_NEW_FILE;
                }
                break;
              }

              case EOB_ACT_CONTINUE_SCAN:
                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_match;

              case EOB_ACT_LAST_MATCH:
                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_find_action;
            }
          break;
        }

        default:
          YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    }   /* end of scanning one token */
  }     /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(void)
{
  char* dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char* source = (yytext_ptr);
  int number_to_move, i;
  int ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
  { /* Don't try to fill the buffer, so this is an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1)
    {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else
    {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else
  {
    int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0)
    { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer)
      {
        int new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char*)
          /* Include room in for 2 EOB chars. */
          yyrealloc((void*)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2));
      }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = NULL;

      if (!b->yy_ch_buf)
        YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE)
      num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0)
  {
    if (number_to_move == YY_MORE_ADJ)
    {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else
    {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
  {
    /* Extend the array by 50%, plus the number we really need. */
    int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
      (char*)yyrealloc((void*)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
    /* "- 2" to take care of EOB's */
    YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(void)
{
  yy_state_type yy_current_state;
  char* yy_cp;

  yy_current_state = (yy_start);
  yy_current_state += YY_AT_BOL();

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp)
  {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state])
    {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 968)
        yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
{
  int yy_is_jam;
  char* yy_cp = (yy_c_buf_p);

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state])
  {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos) = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
  {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 968)
      yy_c = yy_meta[yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  yy_is_jam = (yy_current_state == 967);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* yy_bp)
{
  char* yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
  { /* need to shift things up to make room */
    /* +2 for EOB chars. */
    int number_to_move = (yy_n_chars) + 2;
    char* dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    char* source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) =
      (int)YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  if (c == '\n')
  {
    --yylineno;
  }

  (yytext_ptr) = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void)
#else
static int input(void)
#endif

{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR)
  {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else
    { /* need more input */
      int offset = (int)((yy_c_buf_p) - (yytext_ptr));
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer())
      {
        case EOB_ACT_LAST_MATCH:
          /* This happens because yy_g_n_b()
           * sees that we've accumulated a
           * token and flags that we need to
           * try matching the token before
           * proceeding.  But for input(),
           * there's no matching to consider.
           * So convert the EOB_ACT_LAST_MATCH
           * to EOB_ACT_END_OF_FILE.
           */

          /* Reset buffer status. */
          yyrestart(yyin);

          /*FALLTHROUGH*/

        case EOB_ACT_END_OF_FILE:
        {
          if (yywrap())
            return 0;

          if (!(yy_did_buffer_switch_on_eof))
            YY_NEW_FILE;
#ifdef __cplusplus
          return yyinput();
#else
          return input();
#endif
        }

        case EOB_ACT_CONTINUE_SCAN:
          (yy_c_buf_p) = (yytext_ptr) + offset;
          break;
      }
    }
  }

  c = *(unsigned char*)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';              /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
  if (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

    yylineno++;
  ;

  return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE* input_file)
{

  if (!YY_CURRENT_BUFFER)
  {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
{

  /* TODO. We should be able to replace this entire function body
   * with
   *    yypop_buffer_state();
   *    yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state(void)
{
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char*)yyalloc((yy_size_t)(b->yy_buf_size + 2));
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yy_delete_buffer(YY_BUFFER_STATE b)
{

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    yyfree((void*)b->yy_ch_buf);

  yyfree((void*)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file)

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER)
  {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;

  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yy_flush_buffer(YY_BUFFER_STATE b)
{
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer)
{
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state(void)
{
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER)
  {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(void)
{
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack))
  {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
    (yy_buffer_stack) =
      (struct yy_buffer_state**)yyalloc(num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1)
  {

    /* Increase the buffer to prepare for a possible push. */
    yy_size_t grow_size = 8 /* arbitrary grow size */;

    num_to_alloc = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc(
      (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset(
      (yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size)
{
  YY_BUFFER_STATE b;

  if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
    base[size - 1] != YY_END_OF_BUFFER_CHAR)
    /* They forgot to leave room for the EOB's. */
    return NULL;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

  b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = NULL;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  yy_switch_to_buffer(b);

  return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char* yystr)
{

  return yy_scan_bytes(yystr, (int)strlen(yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char* yybytes, int _yybytes_len)
{
  YY_BUFFER_STATE b;
  char* buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = (yy_size_t)(_yybytes_len + 2);
  buf = (char*)yyalloc(n);
  if (!buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

  for (i = 0; i < _yybytes_len; ++i)
    buf[i] = yybytes[i];

  buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

  b = yy_scan_buffer(buf, n);
  if (!b)
    YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char* msg)
{
  fprintf(stderr, "%s\n", msg);
  exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    yytext[yyleng] = (yy_hold_char);                                                               \
    (yy_c_buf_p) = yytext + yyless_macro_arg;                                                      \
    (yy_hold_char) = *(yy_c_buf_p);                                                                \
    *(yy_c_buf_p) = '\0';                                                                          \
    yyleng = yyless_macro_arg;                                                                     \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno(void)
{

  return yylineno;
}

/** Get the input stream.
 *
 */
FILE* yyget_in(void)
{
  return yyin;
}

/** Get the output stream.
 *
 */
FILE* yyget_out(void)
{
  return yyout;
}

/** Get the length of the current token.
 *
 */
int yyget_leng(void)
{
  return yyleng;
}

/** Get the current token.
 *
 */

char* yyget_text(void)
{
  return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno(int _line_number)
{

  yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE* _in_str)
{
  yyin = _in_str;
}

void yyset_out(FILE* _out_str)
{
  yyout = _out_str;
}

int yyget_debug(void)
{
  return yy_flex_debug;
}

void yyset_debug(int _bdebug)
{
  yy_flex_debug = _bdebug;
}

static int yy_init_globals(void)
{
  /* Initialization is the same as for the non-reentrant scanner.
   * This function is called from yylex_destroy(), so don't allocate here.
   */

  /* We do not touch yylineno unless the option is enabled. */
  yylineno = 1;

  (yy_buffer_stack) = NULL;
  (yy_buffer_stack_top) = 0;
  (yy_buffer_stack_max) = 0;
  (yy_c_buf_p) = NULL;
  (yy_init) = 0;
  (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
  yyin = stdin;
  yyout = stdout;
#else
  yyin = NULL;
  yyout = NULL;
#endif

  /* For future reference: Set errno on error, since we are called by
   * yylex_init()
   */
  return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(void)
{

  /* Pop the buffer stack, destroying each element. */
  while (YY_CURRENT_BUFFER)
  {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    yypop_buffer_state();
  }

  /* Destroy the stack itself. */
  yyfree((yy_buffer_stack));
  (yy_buffer_stack) = NULL;

  /* Reset the globals. This is important in a non-reentrant scanner so the next time
   * yylex() is called, initialization will occur. */
  yy_init_globals();

  return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char* s1, const char* s2, int n)
{

  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char* s)
{
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void* yyalloc(yy_size_t size)
{
  return malloc(size);
}

void* yyrealloc(void* ptr, yy_size_t size)
{

  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return realloc(ptr, size);
}

void yyfree(void* ptr)
{
  free((char*)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

/*
 * Return a parenthetical macro arg list as a new string.
 */
char* get_macro_arguments()
{
  char* cp = NULL;
  size_t i = 0;
  int depth;
  int ws = 0;
  int sl = 0;
  int c1 = input();

  if (c1 == '\0')
  {
    if (pop_buffer() == 0)
    {
      return NULL;
    }
  }

  while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
  {
    c1 = input();
  }

  cp = (char*)malloc(4);

  if (c1 != '(')
  {
    unput(c1);
    free(cp);
    return NULL;
  }

  cp[i++] = '(';
  depth = 1;
  c1 = input();

  for (;;)
  {
    ws = 0;
    sl = 0;
    /* skip all whitespace */
    while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
    {
      ws = 1;
      c1 = input();
    }
    if (c1 == '/')
    {
      c1 = input();
      if (c1 == '*')
      {
        /* skip a C style comment */
        ws = 1;
        if (skip_comment() == 0)
        {
          return NULL;
        }
        c1 = input();
      }
      else if (c1 == '/')
      {
        /* skip a C++ style comment */
        ws = 1;
        do
        {
          c1 = input();
        } while (c1 != '\n' && c1 != '\0');
        if (c1 == '\0')
        {
          return NULL;
        }
        c1 = input();
      }
      else
      {
        sl = 1;
      }
    }
    if (ws)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = ' ';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (sl)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = '/';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (c1 == '\"' || c1 == '\'')
    {
      int c2 = c1;
      int escaped = 2;
      int firstloop = 1;
      do
      {
        if (escaped)
        {
          --escaped;
        }
        if (!firstloop)
        {
          c1 = input();
        }
        firstloop = 0;
        if (c1 == '\0')
        {
          break;
        }
        if (escaped == 0 && c1 == '\\')
        {
          escaped = 2;
        }
        cp[i++] = (char)c1;
        if (i >= 4 && (i & (i - 1)) == 0)
        {
          char* oldcp = cp;
          cp = (char*)realloc(cp, 2 * i);
          if (!cp)
          {
            free(oldcp);
            return NULL;
          }
        }
      } while (c1 != c2 || escaped);
    }
    else if (c1 != '\0')
    {
      cp[i++] = (char)c1;
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
      cp[i] = '\0';
      if (c1 == '(')
      {
        depth++;
      }
      if (c1 == ')')
      {
        if (--depth == 0)
        {
          break;
        }
      }
    }
    else
    {
      return NULL;
    }
    c1 = input();
  }

  return cp;
}

void skip_macro_arguments()
{
  char* p = get_macro_arguments();
  free(p);
}

/*
 * Skip a C-style comment, return 0 if unterminated.
 */
int skip_comment()
{
  int savelineno = yylineno;
  int c1 = 0, c2 = input();
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (c1 == '*' && c2 == '/')
      break;
    c1 = c2;
    c2 = input();
  }
  return 1;
}

/*
 * If token contains a comment, make sure whole comment is skipped.
 */
int skip_trailing_comment(const char* text, size_t l)
{
  const char* cp = text;
  const char* ep = text + l;
  int incomment = 0;

  while (cp < ep)
  {
    while (cp < ep && *cp != '/' && *cp != '\"')
    {
      cp++;
    }
    if (cp >= ep)
    {
      break;
    }
    else if (cp[0] == '/' && cp[1] == '*')
    {
      incomment = 1;
      cp += 2;
      while (cp < ep && *cp != '*')
      {
        cp++;
      }
      if (cp[0] == '*' && cp[1] == '/')
      {
        incomment = 0;
        cp += 2;
      }
      else
      {
        cp++;
      }
    }
    else if (cp[0] == '\"')
    {
      cp++;
      while (cp < ep)
      {
        while (cp < ep && *cp != '\\' && *cp != '\"')
        {
          cp++;
        }
        if (cp >= ep)
        {
          break;
        }
        else if (*cp == '\"')
        {
          cp++;
          break;
        }
        else /* if (*cp == '\\') */
        {
          cp += 2;
        }
      }
    }
    else
    {
      cp++;
    }
  }

  if (incomment)
  {
    return skip_comment();
  }

  return 1;
}

/*
 * Skip ahead until the next preprocessor directive.
 * This will eat the '#' that starts the directive.
 * Return 0 if none found.
 */
int skip_to_next_directive()
{
  /* state == 0 at the start of a line */
  int state = 0;
  int c;

  c = input();

  while (c != 0 && c != EOF)
  {
    /* whitespace */
    if (c == ' ' || c == '\t')
    {
      c = input();
    }
    /* newline renews the start-of-line state */
    else if (c == '\n')
    {
      state = 0;
      c = input();
    }
    /* skip comments */
    else if (c == '/')
    {
      state = 1;
      if ((c = input()) == '*')
      {
        if (skip_comment() == 0)
        {
          return 0;
        }
        c = input();
      }
    }
    /* skip escaped characters */
    else if (c == '\\')
    {
      state = 1;
      if ((c = input()) == '\r')
      {
        if ((c = input()) == '\n')
        {
          c = input();
        }
      }
      else if (c != 0 && c != EOF)
      {
        c = input();
      }
    }
    /* any other chars except '#' at start of line */
    else if (c != '#' || state != 0)
    {
      state = 1;
      c = input();
    }
    else
    {
      break;
    }
  }

  return c;
}

/*
 * Skip to the next #else or #elif or #endif
 */
int skip_conditional_block()
{
  static char* linebuf = NULL;
  static size_t linemaxlen = 80;
  size_t i;
  int c;
  int result;

  if (linebuf == 0)
  {
    linebuf = (char*)malloc(linemaxlen);
  }

  for (;;)
  {
    if (skip_to_next_directive() == 0)
    {
      return 0;
    }
    c = input();
    while (c == ' ' || c == '\t')
    {
      c = input();
    }
    if (c == 0 || c == EOF)
    {
      return 0;
    }

    /* eat the whole line */
    i = 0;
    linebuf[i++] = '#';
    while (c != 0 && c != EOF && c != '\n')
    {
      if (i >= linemaxlen - 5)
      {
        char* oldlinebuf = linebuf;
        linemaxlen += i + 5;
        linebuf = (char*)realloc(linebuf, linemaxlen);
        if (!linebuf)
        {
          free(oldlinebuf);
          return 0;
        }
      }
      linebuf[i++] = c;
      /* be sure to skip escaped newlines */
      if (c == '\\')
      {
        c = input();
        linebuf[i++] = c;
        if (c == '\r')
        {
          c = input();
          linebuf[i++] = c;
        }
      }
      c = input();
    }
    linebuf[i++] = c;

    result = vtkParsePreprocess_HandleDirective(preprocessor, linebuf);
    if (result != VTK_PARSE_SKIP && result != VTK_PARSE_OK)
    {
      print_preprocessor_error(result, linebuf, i);
    }
    else if (result != VTK_PARSE_SKIP)
    {
      break;
    }
  }

  return 1;
}

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 */
int skip_ahead_multi(const char* strings[])
{
  char textbuf[SKIP_MATCH_MAXLEN + 1];
  int c = 0;
  size_t i;

  for (i = 0; i < (SKIP_MATCH_MAXLEN + 1); i++)
  {
    textbuf[i] = '\0';
  }

  for (;;)
  {
    for (i = 0; i < SKIP_MATCH_MAXLEN; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    if (c == 0 || c == EOF)
    {
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, NULL, 0);
      return 0;
    }

    textbuf[SKIP_MATCH_MAXLEN - 1] = c;

    for (i = 0; strings[i]; i++)
    {
      if (strcmp(&textbuf[SKIP_MATCH_MAXLEN - strlen(strings[i])], strings[i]) == 0)
      {
        break;
      }
    }
    if (strings[i])
    {
      break;
    }
  }

  while (c != 0 && c != EOF && c != '\n')
  {
    c = input();
  }

  return 1;
}

/*
 * Skip ahead until the string is found.
 */
int skip_ahead_until(const char* text)
{
  const char* strings[2];
  strings[0] = text;
  strings[1] = NULL;

  return skip_ahead_multi(strings);
}

/*
 * Called for doxygen C-style comments
 */
void doxygen_comment()
{
  char linetext[256];
  int savelineno = yylineno;
  int asterisk, isfirstline = 1;
  int type = DoxygenComment;
  int l = 0, i = 0, base = yyleng;
  int c1 = 0, c2 = input();
  for (l = 0; l < yyleng; l++)
  {
    linetext[l] = yytext[l];
  }
  if (l > 0 && yytext[l - 1] == '<')
  {
    type = TrailingComment;
  }
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (l < 256)
    {
      linetext[l++] = (char)c2;
    }
    if (c2 == '\n' || (c1 == '*' && c2 == '/'))
    {
      if (l >= 2 && linetext[l - 2] == '*' && linetext[l - 1] == '/')
      {
        l -= 2;
      }
      while (l > 0 &&
        (linetext[l - 1] == '\n' || linetext[l - 1] == '\r' || linetext[l - 1] == '\t' ||
          linetext[l - 1] == ' '))
      {
        l--;
      }
      if (!isfirstline)
      {
        /* reduce the base indentation if chars occur before base */
        asterisk = 0;
        for (i = yyleng - 3; i < base && i < l; i++)
        {
          if (linetext[i] == '*' && asterisk == 0)
          {
            asterisk = 1;
          }
          else if (linetext[i] != ' ')
          {
            break;
          }
        }
        if (i > yyleng - 3 && i < l && linetext[i] != ' ' && linetext[i - 1] == ' ')
        {
          i--;
        }
        base = i;
      }
      if (l > base)
      {
        i = base;
        l -= base;
        addCommentLine(&linetext[i], l, type);
      }
      else if (c1 != '*' || c2 != '/')
      {
        addCommentLine("", 0, type);
      }
      if (isfirstline)
      {
        isfirstline = 0;
        base = 256;
      }
      l = 0;
      if (c1 == '*' && c2 == '/')
      {
        break;
      }
    }
    c1 = c2;
    c2 = input();
  }
}

/*
 * Called for //! and /// doxygen comments (handles just one line)
 */
void doxygen_cpp_comment()
{
  int type = DoxygenComment;
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  while (pos < yyleng && yytext[pos - 1] == '/' && yytext[pos] == '/')
    pos++;
  if (pos < yyleng && yytext[pos] == '!')
    pos++;
  if (pos < yyleng && yytext[pos] == '<')
  {
    pos++;
    type = TrailingComment;
  }
  addCommentLine(&yytext[pos], yyleng - pos, type);
}

/*
 * Called for ///@{
 */
void doxygen_group_start()
{
  /* Set the "ingroup" marker */
  setCommentMemberGroup(1);
}

/*
 * Called for ///@}
 */
void doxygen_group_end()
{
  /* Clear the "ingroup" marker */
  setCommentMemberGroup(0);
}

/*
 * Called for // Description:
 */
void vtk_comment()
{
  setCommentState(NormalComment);
}

/*
 * Called for // .NAME
 */
void vtk_name_comment()
{
  int pos = 1;
  while (yytext[pos - 1] != 'M' || yytext[pos] != 'E')
  {
    pos++;
  }
  pos++;
  setCommentState(NameComment);
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called for // .SECTION
 */
void vtk_section_comment()
{
  int pos = 1;
  while (yytext[pos - 1] != 'O' || yytext[pos] != 'N')
  {
    pos++;
  }
  pos++;
  if (pos < yyleng && yytext[pos] == ' ')
  {
    pos++;
  }

  if (yyleng - pos >= 11 && strncmp(&yytext[pos], "Description", 11) == 0)
  {
    setCommentState(DescriptionComment);
  }
  else if (yyleng - pos >= 8 &&
    (strncmp(&yytext[pos], "See Also", 8) == 0 || strncmp(&yytext[pos], "see also", 8) == 0))
  {
    setCommentState(SeeAlsoComment);
  }
  else if (yyleng - pos >= 7 && strncmp(&yytext[pos], "Caveats", 7) == 0)
  {
    setCommentState(CaveatsComment);
  }
  else
  {
    cpp_comment_line();
  }
}

/*
 * Called for each line that has a C++ comment but no code, unless the
 * comment is recognized as beginning a VTK or doxygen comment.
 */
void cpp_comment_line()
{
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called whenever a blank line is encountered.
 */
void blank_line()
{
  commentBreak();
}

/*
 * Convert a raw string into a non-raw string.
 */
const char* raw_string(const char* begin)
{
  int savelineno = yylineno;
  char* textbuf;
  int c = 0;
  const char* delim;
  const char* cp = begin;
  char* dp;
  char* result;
  size_t i, j, n;
  size_t m = 1024;

  result = (char*)malloc(m);
  dp = result;

  while (*cp != '\"')
  {
    *dp++ = *cp++;
  }
  --dp;
  *dp++ = *cp++;

  delim = cp;

  for (n = 0;; n++)
  {
    if (delim[n] == '(')
    {
      break;
    }
  }

  textbuf = (char*)malloc(n + 1);

  for (i = 0; i < n + 1; i++)
  {
    c = input();
    textbuf[i] = c;
  }

  while (c != EOF)
  {
    if (textbuf[0] == ')' && (n == 0 || strncmp(&textbuf[1], delim, n) == 0))
    {
      break;
    }

    j = dp - result;
    if (j > m - 8)
    {
      m += 1024;
      result = (char*)realloc(result, m);
      if (!result)
      {
        print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
        exit(1);
      }
      dp = result + j;
    }

    if ((*textbuf >= ' ' && *textbuf <= '~') || (*textbuf & 0x80) != 0)
    {
      *dp++ = *textbuf;
    }
    else
      switch (*textbuf)
      {
        case '\a':
          *dp++ = '\\';
          *dp++ = 'a';
          break;
        case '\b':
          *dp++ = '\\';
          *dp++ = 'b';
          break;
        case '\f':
          *dp++ = '\\';
          *dp++ = 'f';
          break;
        case '\n':
          *dp++ = '\\';
          *dp++ = 'n';
          break;
        case '\r':
          *dp++ = '\\';
          *dp++ = 'r';
          break;
        case '\t':
          *dp++ = '\\';
          *dp++ = 't';
          break;
        case '\v':
          *dp++ = '\\';
          *dp++ = 'v';
          break;
        case '\\':
          *dp++ = '\\';
          *dp++ = '\\';
          break;
        case '\'':
          *dp++ = '\\';
          *dp++ = '\'';
          break;
        case '\"':
          *dp++ = '\\';
          *dp++ = '\"';
          break;
        default:
          sprintf(dp, "\\%3.3o", *textbuf);
          dp += 4;
          break;
      }

    for (i = 0; i < n; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    textbuf[n] = c;
  }

  if (c == EOF || '\"' != input())
  {
    yylineno = savelineno;
    print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Unterminated raw string.", 24);
    exit(1);
  }

  *dp++ = '\"';

  c = input();
  if (c == '_')
  {
    do
    {
      *dp++ = c;
      c = input();
    } while (vtkParse_CharType(c, CPRE_XID));
  }
  unput(c);

  *dp = '\0';
  cp = vtkstrdup(result);
  free(result);
  free(textbuf);

  return cp;
}

/*
 * buffer stack, used for macro expansion and include files
 */
static size_t buffer_stack_size = 0;
static YY_BUFFER_STATE* buffer_stack = NULL;

/*
 * push the current buffer onto the buffer stack.
 */
void push_buffer()
{
  size_t n = buffer_stack_size;
  if (buffer_stack == NULL)
  {
    buffer_stack = (YY_BUFFER_STATE*)malloc(4 * sizeof(YY_BUFFER_STATE));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    buffer_stack = (YY_BUFFER_STATE*)realloc(buffer_stack, 2 * n * sizeof(YY_BUFFER_STATE));
    if (!buffer_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  buffer_stack[buffer_stack_size++] = YY_CURRENT_BUFFER;
}

/*
 * pop the buffer stack and restore the previous buffer
 */
int pop_buffer()
{
  if (in_macro())
  {
    pop_macro();
  }
  else
  {
    pop_include();
  }
  if (buffer_stack_size == 0)
  {
    return 0;
  }
  yy_delete_buffer(YY_CURRENT_BUFFER);
  yy_switch_to_buffer(buffer_stack[--buffer_stack_size]);
  return 1;
}

/*
 * include stack, to tell what include is being evaluated
 */
static size_t include_stack_size = 0;
static FileInfo** include_stack = NULL;
static int* lineno_stack = NULL;

/*
 * push the current include onto the include stack.
 */
void push_include(const char* filename)
{
  FileInfo* file_info = NULL;
  int same_file = 0;
  size_t n = include_stack_size;

  if (include_stack == NULL)
  {
    include_stack = (FileInfo**)malloc(4 * sizeof(FileInfo*));
    lineno_stack = (int*)malloc(4 * sizeof(int));
  }

  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    include_stack = (FileInfo**)realloc(include_stack, 2 * n * sizeof(FileInfo*));
    if (!include_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
    lineno_stack = (int*)realloc(lineno_stack, 2 * n * sizeof(int));
    if (!lineno_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }

  lineno_stack[include_stack_size] = yyget_lineno();
  yyset_lineno(0);
  include_stack[include_stack_size++] = data;

  /* if the file is including itself */
  if (filename == data->FileName ||
    (filename != 0 && data->FileName != 0 && strcmp(filename, data->FileName) == 0))
  {
    same_file = 1;
  }

  /* make a new fileinfo, but only if we are in the base namespace
   * and only if the only items added so far are constants */
  if (!same_file && currentNamespace == data->Contents &&
    data->Contents->NumberOfItems == data->Contents->NumberOfConstants)
  {
    file_info = (FileInfo*)malloc(sizeof(FileInfo));
    vtkParse_InitFile(file_info);
    file_info->FileName = vtkstrdup(filename);
    file_info->Contents = (NamespaceInfo*)malloc(sizeof(NamespaceInfo));
    vtkParse_InitNamespace(file_info->Contents);
    vtkParse_AddIncludeToFile(data, file_info);
    file_info->Strings = data->Strings;
    data = file_info;
    currentNamespace = file_info->Contents;
  }
}

/*
 * pop the include stack
 */
void pop_include()
{
  if (include_stack_size > 0)
  {
    --include_stack_size;
    fclose(yyin);
    yyset_lineno(lineno_stack[include_stack_size]);
    if (data != include_stack[include_stack_size])
    {
      data = include_stack[include_stack_size];
      currentNamespace = data->Contents;
    }
  }
}

/*
 * macro stack, to tell what macro is being evaluated
 */
static size_t macro_stack_size = 0;
static MacroInfo** macro_stack = NULL;

/*
 * push the current macro onto the macro stack.
 */
void push_macro(MacroInfo* macro)
{
  size_t n = macro_stack_size;
  if (macro_stack == NULL)
  {
    macro_stack = (MacroInfo**)malloc(4 * sizeof(MacroInfo*));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    macro_stack = (MacroInfo**)realloc(macro_stack, 2 * n * sizeof(MacroInfo*));
    if (!macro_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  macro_stack[macro_stack_size++] = macro;
  if (macro)
  {
    macro->IsExcluded = 1;
    if (macro_stack_size == 1)
    {
      macroName = macro->Name;
      macroUsed = 0;
      macroEnded = 0;
    }
  }
}

/*
 * pop the macro stack
 */
void pop_macro()
{
  MacroInfo* macro;

  if (macro_stack_size > 0)
  {
    macro = macro_stack[--macro_stack_size];
    if (macro)
    {
      macro->IsExcluded = 0;
    }
  }
  macroEnded = 1;
}

/*
 * are we currently processing a macro?
 */
int in_macro()
{
  return (macro_stack_size > 0);
}

/*
 * print a preprocessor error code with filename and line number.
 */
void print_preprocessor_error(int result, const char* cp, size_t n)
{
  const char* text = "";

  switch (result)
  {
    case VTK_PARSE_OK:
    case VTK_PARSE_SKIP:
      return;
    case VTK_PARSE_PREPROC_DOUBLE:
      text = "double in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_FLOAT:
      text = "float in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_STRING:
      text = "string in preprocessor conditional";
      break;
    case VTK_PARSE_MACRO_UNDEFINED:
      text = "undefined macro";
      break;
    case VTK_PARSE_MACRO_REDEFINED:
      text = "redefined macro";
      break;
    case VTK_PARSE_FILE_NOT_FOUND:
      text = "file not found";
      break;
    case VTK_PARSE_FILE_OPEN_ERROR:
      text = "can\'t open file";
      break;
    case VTK_PARSE_FILE_READ_ERROR:
      text = "input/output error";
      break;
    case VTK_PARSE_MACRO_NUMARGS:
      text = "wrong number of macro args";
      break;
    case VTK_PARSE_SYNTAX_ERROR:
      text = "syntax error";
      break;
    case VTK_PARSE_OUT_OF_MEMORY:
      text = "out of memory";
      break;
  }

  /* be silent about missing include files */
  if (result == VTK_PARSE_FILE_NOT_FOUND)
  {
    return;
  }

  print_parser_error(text, cp, n);
}

/*
 * print an error with filename and line number.
 */
void print_parser_error(const char* text, const char* cp, size_t n)
{
  size_t j = 0;
  const char* fn = "(none)";

  if (CommandName)
  {
    fprintf(yyout, "%s: ", CommandName);
  }

  if (data->FileName)
  {
    fn = data->FileName;
  }
  fprintf(yyout, "In %s:", fn);
  for (j = 0; j < include_stack_size; j++)
  {
    fprintf(yyout, "%i:\nIn %s:", lineno_stack[j], include_stack[j]->FileName);
  }
  fprintf(yyout, "%i:", yylineno);

  if (cp)
  {
    fprintf(yyout, " %s: %*.*s\n", text, (int)n, (int)n, cp);
  }
  else if (text)
  {
    fprintf(yyout, " %s.\n", text);
  }
  else
  {
    fprintf(yyout, "\n");
  }
}

/*
 * Execute a preprocessor directive.
 */
void preprocessor_directive(const char* text, size_t l)
{
  int result = 0;
  size_t n = 0;
  const char* cp = text;
  const char* ep = text + l;
  const char* directive = NULL;

  /* find the directive, store its length in "n" */
  while (*cp == ' ' || *cp == '\t')
  {
    cp++;
  }
  if (*cp == '#')
  {
    cp++;
  }
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }
  directive = cp;
  while (*cp >= 'a' && *cp <= 'z' && cp < ep)
  {
    cp++;
  }
  n = cp - directive;
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }

  if (n == 7 && strncmp(directive, "include", n) == 0)
  {
    /* include files */
    int already_loaded = 0;
    if (*cp == '<' || *cp == '\"')
    {
      /* if asked to recurse into header files */
      if (Recursive && ep - cp > 3)
      {
        const char* dp;
        dp = vtkParsePreprocess_FindIncludeFile(preprocessor, &cp[1],
          (*cp != '\"' ? VTK_PARSE_SYSTEM_INCLUDE : VTK_PARSE_SOURCE_INCLUDE), &already_loaded);
        if (dp)
        {
          yyin = vtkParse_FileOpen(dp, "r");
          if (yyin)
          {
            push_include(dp);
            push_buffer();
            yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
            return;
          }
        }
      }
    }
  }

  /* let the preprocessor handle the directive */
  result = vtkParsePreprocess_HandleDirective(preprocessor, text);

  if (result == VTK_PARSE_SKIP)
  {
    skip_conditional_block();
  }
  else if (result != VTK_PARSE_OK)
  {
    print_preprocessor_error(result, text, l);
    if ((result & VTK_PARSE_FATAL_ERROR) != 0)
    {
      exit(1);
    }
  }
  else if (n == 6 && strncmp(directive, "define", n) == 0)
  {
    closeComment();
    if (ep - cp > 4 && strncmp(cp, "VTK", 3) == 0)
    {
      /* macros that start with "VTK" */
      MacroInfo* macro;

      macro = vtkParsePreprocess_GetMacro(preprocessor, cp);
      if (macro && macro->Definition && !macro->IsFunction)
      {
        /* if macro evaluates to a constant, add it as a constant */
        macro->IsExcluded = 1;
        if (guess_constant_type(macro->Definition) == 0)
        {
          result = VTK_PARSE_MACRO_UNDEFINED;
        }
        macro->IsExcluded = 0;
        if (result < VTK_PARSE_MACRO_UNDEFINED)
        {
          add_constant(vtkstrdup(macro->Name), vtkstrdup(macro->Definition), 0, 0, NULL, 1);
        }
      }
    }
  }
}
